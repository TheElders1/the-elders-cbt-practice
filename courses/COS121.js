window.quizData = {
  "title": "COS121 - Problem Solving",
  "questions": [
    {
      "question": "Define 'problem' in the context of computing.",
      "options": [
        "A piece of code that doesn't compile",
        "A situation or challenge that requires a solution",
        "A complex algorithm",
        "An error in a program"
      ],
      "answer": "A situation or challenge that requires a solution",
      "explanation": "The introductory section of the lecture defines a problem as a situation or challenge that demands a solution."
    },
    {
      "question": "What is 'problem solving'?",
      "options": [
        "The process of writing code quickly",
        "The process of finding solutions to difficult or complex issues",
        "The act of debugging a program",
        "The study of algorithms"
      ],
      "answer": "The process of finding solutions to difficult or complex issues",
      "explanation": "Problem Solving is defined in the lecture as the systematic process of discovering solutions to challenging or intricate problems."
    },
    {
      "question": "List three reasons why problem solving is important in computing.",
      "options": [
        "It simplifies syntax, reduces errors, and speeds up execution.",
        "It is the foundation of programming, drives innovation, and improves efficiency.",
        "It automates tasks, creates new software, and manages hardware.",
        "It provides debugging tools, enhances security, and aids in documentation."
      ],
      "answer": "It is the foundation of programming, drives innovation, and improves efficiency.",
      "explanation": "The lecture highlights problem solving's importance as the 'Foundation of Programming', a driver of 'Innovation', and a means to 'Efficiency'."
    },
    {
      "question": "Explain 'Efficiency' as a benefit of problem solving.",
      "options": [
        "The ability to produce aesthetically pleasing code.",
        "Finding optimal solutions that saves time, resources, and improves user experience.",
        "The speed at which a programmer can write code.",
        "The simplicity of the problem statement."
      ],
      "answer": "Finding optimal solutions that saves time, resources, and improves user experience.",
      "explanation": "Efficiency in problem-solving focuses on developing the best possible solutions that optimize time and resource usage while enhancing the user's experience."
    },
    {
      "question": "Explain 'Adaptability' as a benefit of problem solving.",
      "options": [
        "The capacity to quickly switch between programming languages.",
        "The ability to solve problems makes you flexible in a rapidly changing tech landscape.",
        "The ease of adapting old solutions to new problems without modification.",
        "The speed with which a system can adapt to new users."
      ],
      "answer": "The ability to solve problems makes you flexible in a rapidly changing tech landscape.",
      "explanation": "Adaptability is presented as the capacity to effectively address problems, thereby enabling flexibility within the constantly evolving technological environment."
    },
    {
      "question": "How does problem solving relate to 'Debugging'?",
      "options": [
        "Problem-solving is a separate skill from debugging.",
        "Debugging is the initial step of problem-solving.",
        "Debugging is a form of problem-solving, focused on identifying and fixing errors.",
        "Problem-solving eliminates the need for debugging."
      ],
      "answer": "Debugging is a form of problem-solving, focused on identifying and fixing errors.",
      "explanation": "The lecture explicitly states that debugging, which involves finding and correcting errors (bugs), is itself a form of problem-solving."
    },
    {
      "question": "What kind of problems are characterized by a 'Known Solution Path'?",
      "options": [
        "Non-routine problems.",
        "Complex problems.",
        "Routine problems.",
        "Ill-defined problems."
      ],
      "answer": "Routine problems.",
      "explanation": "Routine problems are defined by having a predictable sequence of steps or an already established path to their solution."
    },
    {
      "question": "Give two characteristics of a 'routine problem'.",
      "options": [
        "Novel and requires creativity.",
        "Repetitive and rule-based.",
        "Ill-defined and high risk.",
        "Iterative and unique."
      ],
      "answer": "Repetitive and rule-based.",
      "explanation": "Routine problems are often repetitive, occurring frequently in similar forms, and their solutions typically follow predefined rules or algorithms."
    },
    {
      "question": "Provide an example of a routine problem in computing.",
      "options": [
        "Designing a novel AI algorithm.",
        "Troubleshooting a 'no internet connection' issue.",
        "Scaling an application for exponential growth.",
        "Optimizing a legacy system with unknown bottlenecks."
      ],
      "answer": "Troubleshooting a 'no internet connection' issue.",
      "explanation": "Troubleshooting a 'no internet connection' issue is listed as a routine problem, implying a known method for resolution."
    },
    {
      "question": "What type of problem is often described as 'novel' or 'unusual'?",
      "options": [
        "Routine problems.",
        "Deterministic problems.",
        "Automatable problems.",
        "Non-routine problems."
      ],
      "answer": "Non-routine problems.",
      "explanation": "Non-routine problems are characterized by being novel, unusual, and lacking immediately obvious solutions."
    },
    {
      "question": "Give two characteristics of a 'non-routine problem'.",
      "options": [
        "Deterministic and repetitive.",
        "Known solution path and rule-based.",
        "Unique/novel and requires creativity & insight.",
        "Structured and automatable."
      ],
      "answer": "Unique/novel and requires creativity & insight.",
      "explanation": "Non-routine problems are unique or novel, meaning they haven't been encountered in the exact form before, and they demand creativity and insight to solve."
    },
    {
      "question": "Provide an example of a non-routine problem in computing.",
      "options": [
        "Sorting a list of numbers.",
        "Validating user input.",
        "Designing a novel AI algorithm.",
        "Resetting a forgotten password."
      ],
      "answer": "Designing a novel AI algorithm.",
      "explanation": "Designing a novel AI algorithm is an example of a non-routine problem, as it requires innovation and a non-standard approach."
    },
    {
      "question": "Why is understanding the difference between routine and non-routine problems important?",
      "options": [
        "It makes all problems solvable.",
        "It helps in choosing the right approach, tools, and mindset for problem-solving.",
        "It allows ignoring complex problems.",
        "It simplifies all problem definitions."
      ],
      "answer": "It helps in choosing the right approach, tools, and mindset for problem-solving.",
      "explanation": "Distinguishing between routine and non-routine problems is crucial for selecting the most appropriate strategy, tools, and perspective for effective problem-solving."
    },
    {
      "question": "What is the Big-O complexity often associated with 'brute-force' solutions to complex problems?",
      "options": [
        "O(1)",
        "O(n)",
        "O(n²)",
        "O(2ⁿ) (Exponential Time)"
      ],
      "answer": "O(2ⁿ) (Exponential Time)",
      "explanation": "Brute-force solutions to complex problems are often associated with Exponential Time complexity (O(2ⁿ)), which is highly inefficient."
    },
    {
      "question": "What is 'abstraction' in problem solving?",
      "options": [
        "Making a problem more complex.",
        "Simplifying a problem by focusing only on essential details and ignoring irrelevant information.",
        "Breaking a problem into smaller sub-problems.",
        "Writing detailed code for a problem."
      ],
      "answer": "Simplifying a problem by focusing only on essential details and ignoring irrelevant information.",
      "explanation": "Abstraction is defined as the process of simplifying a problem by concentrating on its core elements while disregarding less important information."
    },
    {
      "question": "List two key ideas of abstraction.",
      "options": [
        "Increase complexity and ignore patterns.",
        "Focus on all details and solve inefficiently.",
        "Ignore unnecessary complexity and identify core patterns.",
        "Break into smaller tasks and combine solutions."
      ],
      "answer": "Ignore unnecessary complexity and identify core patterns.",
      "explanation": "Two key ideas of abstraction are to ignore unnecessary complexity and to identify the fundamental patterns, structures, or relationships within a problem."
    },
    {
      "question": "Provide an example of what might be ignored when applying abstraction to a problem.",
      "options": [
        "The core functionality of a system.",
        "The physical materials of an elevator's buttons when programming its logic.",
        "The floors an elevator needs to visit.",
        "The requests made to an elevator."
      ],
      "answer": "The physical materials of an elevator's buttons when programming its logic.",
      "explanation": "When programming an elevator system, abstraction allows you to ignore the specific physical materials or brand of buttons, focusing instead on their function (input signals)."
    },
    {
      "question": "Provide an example of what might be focused on when applying abstraction to a problem.",
      "options": [
        "The color of an elevator's interior.",
        "The exact dimensions of a library building.",
        "The floors (states) and requests (inputs) when programming an elevator system.",
        "The specific type of wood used for library shelves."
      ],
      "answer": "The floors (states) and requests (inputs) when programming an elevator system.",
      "explanation": "When programming an elevator system, abstraction focuses on critical elements like the different floors (states) and user requests (inputs)."
    },
    {
      "question": "What is 'decomposition' in problem solving?",
      "options": [
        "Simplifying a problem by ignoring details.",
        "Making a problem more complex.",
        "Breaking a complex problem into smaller, more manageable sub-problems.",
        "Finding an optimal solution."
      ],
      "answer": "Breaking a complex problem into smaller, more manageable sub-problems.",
      "explanation": "Decomposition is defined as the process of dividing a complex problem into smaller, more manageable parts that are easier to solve individually."
    },
    {
      "question": "List two key ideas of decomposition.",
      "options": [
        "Increase complexity and solve dependently.",
        "Combine solutions and focus on overall problem.",
        "Divide and conquer approach and solve smaller tasks independently.",
        "Ignore details and facilitate generalization."
      ],
      "answer": "Divide and conquer approach and solve smaller tasks independently.",
      "explanation": "Two key ideas of decomposition are employing a 'divide and conquer' approach and solving each smaller task independently."
    },
    {
      "question": "How does decomposition relate to the 'Divide and Conquer' approach?",
      "options": [
        "They are opposing strategies.",
        "Decomposition is the practical application of the Divide and Conquer principle.",
        "Divide and Conquer is a tool for abstraction, not decomposition.",
        "They are unrelated concepts."
      ],
      "answer": "Decomposition is the practical application of the Divide and Conquer principle.",
      "explanation": "Decomposition is directly related to the 'Divide and Conquer' principle, as it involves breaking down a problem into smaller, independent sub-problems."
    },
    {
      "question": "What is a benefit of abstraction regarding information overload?",
      "options": [
        "It increases the amount of information to process.",
        "It reduces (mental) Information Overload by filtering out unnecessary details.",
        "It ensures all information is always relevant.",
        "It complicates the reasoning process."
      ],
      "answer": "It reduces (mental) Information Overload by filtering out unnecessary details.",
      "explanation": "Abstraction helps reduce mental information overload by allowing the problem-solver to concentrate on what is truly important and filter out unnecessary details."
    },
    {
      "question": "How does abstraction facilitate generalization?",
      "options": [
        "By making every problem unique.",
        "By identifying a more general version of a problem that might have a known solution.",
        "By limiting solutions to specific cases.",
        "By preventing the reuse of patterns."
      ],
      "answer": "By identifying a more general version of a problem that might have a known solution.",
      "explanation": "Abstraction facilitates generalization by enabling the recognition of a problem's broader form, which may then be solved using existing solutions or approaches."
    },
    {
      "question": "How does decomposition simplify complexity?",
      "options": [
        "By making problems appear larger.",
        "By breaking a daunting problem into smaller, less overwhelming chunks.",
        "By increasing the number of interdependent parts.",
        "By obscuring the core issue."
      ],
      "answer": "By breaking a daunting problem into smaller, less overwhelming chunks.",
      "explanation": "Decomposition simplifies complexity by transforming a large, daunting problem into smaller, more manageable chunks, making it less overwhelming to approach."
    },
    {
      "question": "How does decomposition improve understanding?",
      "options": [
        "By making the overall problem less clear.",
        "By obscuring relationships between parts.",
        "It helps in gaining a clearer understanding of the overall problem and how its various parts relate to each other.",
        "It prevents independent analysis of sub-problems."
      ],
      "answer": "It helps in gaining a clearer understanding of the overall problem and how its various parts relate to each other.",
      "explanation": "Decomposition enhances understanding by providing a clearer view of the overall problem and illuminating how its individual components interrelate."
    },
    {
      "question": "How do abstraction and decomposition often work together in problem solving?",
      "options": [
        "They are used independently to solve different problem types.",
        "Abstraction only happens after decomposition is complete.",
        "They are often used in tandem; problems are decomposed, and then sub-problems are abstracted.",
        "They are conflicting techniques that cannot be combined."
      ],
      "answer": "They are often used in tandem; problems are decomposed, and then sub-problems are abstracted.",
      "explanation": "Abstraction and decomposition are frequently used together: a problem is decomposed into smaller parts, and then each sub-problem is abstracted to focus on its essential elements."
    },
    {
      "question": "When in the problem-solving process is it generally 'too early for decomposition'?",
      "options": [
        "During the 'Devising a Plan' phase.",
        "During the 'Carrying out the Plan' phase.",
        "When still understanding the big picture of the problem.",
        "During the 'Review and Refine' phase."
      ],
      "answer": "When still understanding the big picture of the problem.",
      "explanation": "Decomposition is generally premature when the problem-solver is still in the initial stages of understanding the problem's overall context and scope."
    },
    {
      "question": "When in the problem-solving process does refining abstraction typically occur?",
      "options": [
        "During the initial 'Understand the Problem' phase.",
        "During the 'Analyze the Problem' phase.",
        "During the 'Carrying out the Plan' phase (coding).",
        "During the 'Review and Refine' phase."
      ],
      "answer": "During the 'Analyze the Problem' phase.",
      "explanation": "Refining abstraction typically takes place during the 'Analyze the Problem' phase, where core data and processes are identified and clarified."
    },
    {
      "question": "When performing 'Problem Identification,' what is the first question you should ask?",
      "options": [
        "What are the inputs?",
        "What is the core issue?",
        "Who is affected by the problem?",
        "What are the constraints?"
      ],
      "answer": "What is the core issue?",
      "explanation": "Problem identification begins with the fundamental question: 'What is the core issue?', to avoid premature conclusions."
    },
    {
      "question": "List two categories of questions to ask during the 'Understand the Problem' phase.",
      "options": [
        "Questions about debugging and refactoring.",
        "Questions about coding syntax and data types.",
        "Questions about inputs/outputs and constraints.",
        "Questions about external documentation and user manuals."
      ],
      "answer": "Questions about inputs/outputs and constraints.",
      "explanation": "During the 'Understand the Problem' phase, key questions involve identifying 'What is given? (Inputs)', 'What is required? (Outputs)', and 'What are the constraints?'."
    },
    {
      "question": "List George Polya's four steps to problem solving.",
      "options": [
        "Define, Code, Test, Document.",
        "Analyze, Design, Implement, Evaluate.",
        "Understand the Problem, Devise a Plan, Implement the Solution, Review & Refine.",
        "Identify, Solve, Optimize, Refactor."
      ],
      "answer": "Understand the Problem, Devise a Plan, Implement the Solution, Review & Refine.",
      "explanation": "George Polya's method outlines four critical steps: Understand the Problem, Devise a Plan, Implement the Solution, and Review & Refine."
    },
    {
      "question": "In the 'Understand the Problem' phase, what is the purpose of identifying 'inputs'?",
      "options": [
        "To define the desired outcome.",
        "To know what information is available at the start of the problem.",
        "To identify limitations on the solution.",
        "To determine who is affected by the problem."
      ],
      "answer": "To know what information is available at the start of the problem.",
      "explanation": "Identifying inputs serves to clarify 'what is given' or what information is available from the outset of the problem."
    },
    {
      "question": "In the 'Understand the Problem' phase, what is the purpose of identifying 'outputs'?",
      "options": [
        "To define the initial given data.",
        "To know what results or information are required as the solution.",
        "To set boundaries for the problem.",
        "To determine the method of problem-solving."
      ],
      "answer": "To know what results or information are required as the solution.",
      "explanation": "Identifying outputs is crucial for defining 'what is required' or the specific results that the solution must produce."
    },
    {
      "question": "What are 'constraints' in problem solving? Give an example.",
      "options": [
        "Inputs or outputs; e.g., 'a' and 'b'.",
        "Solutions or methods; e.g., 'recursion'.",
        "Limitations or boundaries; e.g., time, memory, data size.",
        "Auxiliary problems; e.g., 'finding a related theorem'."
      ],
      "answer": "Limitations or boundaries; e.g., time, memory, data size.",
      "explanation": "Constraints are defined as limitations or boundaries that affect the problem, such as limits on available time, memory, or the size of data."
    },
    {
      "question": "Explain 'Problem Decomposition' in the context of understanding a problem.",
      "options": [
        "The process of ignoring minor details.",
        "Breaking down a complex problem into smaller, manageable sub-problems to understand each part more easily.",
        "Finding an analogous problem.",
        "Creating a visual representation of the problem."
      ],
      "answer": "Breaking down a complex problem into smaller, manageable sub-problems to understand each part more easily.",
      "explanation": "Problem Decomposition involves breaking a complex problem into smaller, more manageable sub-problems, making each part easier to understand and solve independently."
    },
    {
      "question": "Name two tools that can aid in understanding a problem.",
      "options": [
        "Debuggers and compilers.",
        "Mind Maps and Flowcharts.",
        "Programming languages and IDEs.",
        "Test programs and profilers."
      ],
      "answer": "Mind Maps and Flowcharts.",
      "explanation": "Mind Maps are useful for visualizing ideas and connections, while Flowcharts provide a diagrammatic representation of processes, both aiding problem understanding."
    },
    {
      "question": "What is the primary use of a 'Mind Map' in problem understanding?",
      "options": [
        "To document code logic.",
        "To visualize ideas and their connections for brainstorming.",
        "To represent step-by-step algorithms graphically.",
        "To track execution flow during debugging."
      ],
      "answer": "To visualize ideas and their connections for brainstorming.",
      "explanation": "Mind Maps are primarily used to visualize ideas and their interconnections, serving as a great tool for brainstorming and breaking down problems."
    },
    {
      "question": "What is the primary use of a 'Flowchart' in problem understanding?",
      "options": [
        "To manage project timelines.",
        "To provide a diagrammatic representation of a process or algorithm.",
        "To write executable code.",
        "To analyze algorithm performance."
      ],
      "answer": "To provide a diagrammatic representation of a process or algorithm.",
      "explanation": "Flowcharts are used to provide a pictorial, step-by-step representation of a process or algorithm, aiding in understanding the flow of logic."
    },
    {
      "question": "What is the primary use of 'Use Cases/User Stories' in problem understanding?",
      "options": [
        "To outline programming language syntax.",
        "To describe how a user interacts with the system to achieve a goal.",
        "To simplify complex mathematical formulas.",
        "To track logical errors in code."
      ],
      "answer": "To describe how a user interacts with the system to achieve a goal.",
      "explanation": "Use Cases and User Stories are tools for describing how an end-user will interact with the system to accomplish specific goals, crucial for understanding user needs."
    },
    {
      "question": "In the 'Devise a Plan' phase, what is the benefit of asking 'Have you seen such a problem before?'",
      "options": [
        "It helps to create an entirely new solution from scratch.",
        "It ensures that the problem is unique and novel.",
        "It allows leveraging existing knowledge and past solutions to similar problems.",
        "It confirms the problem is non-routine."
      ],
      "answer": "It allows leveraging existing knowledge and past solutions to similar problems.",
      "explanation": "Asking this question helps to recall previous experiences and potentially reuse methods or results from problems already solved."
    },
    {
      "question": "What is the 'Brute Force' problem-solving strategy?",
      "options": [
        "Making the locally optimal choice at each step.",
        "Breaking into smaller sub-problems.",
        "Trying all possible solutions until one works, though often inefficient.",
        "Solving overlapping sub-problems by storing results."
      ],
      "answer": "Trying all possible solutions until one works, though often inefficient.",
      "explanation": "Brute Force is a straightforward strategy that explores every possible solution until a correct one is found, often without much optimization."
    },
    {
      "question": "Describe the 'Divide and Conquer' problem-solving strategy.",
      "options": [
        "Trying all possible solutions sequentially.",
        "Breaking a problem into smaller sub-problems, solving them, and combining their solutions.",
        "Making local optimal choices to find a global optimum.",
        "Storing results of sub-problems to avoid re-computation."
      ],
      "answer": "Breaking a problem into smaller sub-problems, solving them, and combining their solutions.",
      "explanation": "The Divide and Conquer strategy involves breaking a problem down into smaller, independent sub-problems, solving each one, and then merging their solutions to solve the original problem."
    },
    {
      "question": "Explain the 'Greedy Approach' strategy.",
      "options": [
        "Always choosing the most complex option.",
        "Making the locally optimal choice at each step, hoping it leads to a global optimum.",
        "Solving problems by exploring all possible paths.",
        "Storing intermediate results for future use."
      ],
      "answer": "Making the locally optimal choice at each step, hoping it leads to a global optimum.",
      "explanation": "The Greedy Approach makes the best immediate choice at each step, with the hope that these local optimal decisions will lead to the best overall solution."
    },
    {
      "question": "What is 'Dynamic Programming'?",
      "options": [
        "A method of generating all possible solutions.",
        "Solving overlapping sub-problems by storing results to avoid re-computation.",
        "A strategy for breaking problems into independent parts.",
        "A technique for exploring paths and backtracking."
      ],
      "answer": "Solving overlapping sub-problems by storing results to avoid re-computation.",
      "explanation": "Dynamic Programming is a technique that optimizes solutions by recognizing and storing the results of overlapping sub-problems, thereby avoiding redundant computations."
    },
    {
      "question": "Describe the 'Backtracking' strategy.",
      "options": [
        "Making a series of choices, and if a choice leads to a dead end, undoing it and trying another.",
        "Always moving forward without reconsidering past choices.",
        "Storing all possible paths to find the best one.",
        "Using recursion to solve problems quickly."
      ],
      "answer": "Making a series of choices, and if a choice leads to a dead end, undoing it and trying another.",
      "explanation": "Backtracking is a problem-solving strategy that explores all possible solution paths, but prunes (abandons) paths early if they are determined not to lead to a valid solution."
    },
    {
      "question": "What is 'Recursion' in the context of problem-solving strategies?",
      "options": [
        "A function calling another function.",
        "A technique where a function calls itself to solve smaller instances of the same problem.",
        "A method for looping through data.",
        "A process for optimizing memory usage."
      ],
      "answer": "A technique where a function calls itself to solve smaller instances of the same problem.",
      "explanation": "Recursion is a programming technique where a function invokes itself to solve smaller, similar versions of the original problem until a base case is met."
    },
    {
      "question": "During 'Carrying out the Plan,' what role do flowcharts and pseudocode play?",
      "options": [
        "They are used for the final coding.",
        "They help in documenting the solution after it's built.",
        "They are used to translate the design aspect of the programming job into implementable logic.",
        "They are tools for debugging syntax errors."
      ],
      "answer": "They help in documenting the solution after it's built.",
      "explanation": "Flowcharts and pseudocode serve as tools to visually or descriptively outline the planned solution, aiding in the translation of the design into actual code during the carrying out phase."
    },
    {
      "question": "List three characteristics of a 'Good Algorithm'.",
      "options": [
        "Ambiguity, infinite loops, high resource usage.",
        "Correctness, efficiency, and finiteness.",
        "Complexity, redundancy, and non-determinism.",
        "Language-specific, informal, and non-terminating."
      ],
      "answer": "Correctness, efficiency, and finiteness.",
      "explanation": "Three key characteristics of a good algorithm are its correctness (producing accurate results), efficiency (using minimal resources), and finiteness (guaranteed to terminate)."
    },
    {
      "question": "Define 'Pseudocode' and explain its primary purpose.",
      "options": [
        "Executable code for quick testing; its purpose is to run programs.",
        "A formal mathematical description; its purpose is to prove algorithm correctness.",
        "An informal, high-level description of an algorithm; its purpose is to plan program logic without strict syntax.",
        "A graphical tool for debugging; its purpose is to visualize errors."
      ],
      "answer": "An informal, high-level description of an algorithm; its purpose is to plan program logic without strict syntax.",
      "explanation": "Pseudocode is an informal, high-level description of an algorithm, primarily used for planning the logical steps of a program without being constrained by precise programming language syntax."
    },
    {
      "question": "What does it mean for an algorithm to be 'language-agnostic'?",
      "options": [
        "It can only be written in one specific language.",
        "It is independent of any particular programming language, allowing broader understanding.",
        "It ignores language rules.",
        "It is designed for multiple human languages."
      ],
      "answer": "It is independent of any particular programming language, allowing broader understanding.",
      "explanation": "A language-agnostic algorithm is designed to be understood and applied across different programming languages, focusing on the logic rather than specific syntax."
    },
    {
      "question": "What is a 'Data Structure'?",
      "options": [
        "A debugging technique.",
        "A particular way of organizing data in a computer so that it can be used efficiently.",
        "A type of algorithm.",
        "A programming paradigm."
      ],
      "answer": "A particular way of organizing data in a computer so that it can be used efficiently.",
      "explanation": "A data structure is defined as a specific method for organizing data within a computer, designed to facilitate efficient storage, retrieval, and manipulation."
    },
    {
      "question": "Name three common data structures mentioned in the notes.",
      "options": [
        "Variables, constants, functions.",
        "If-else statements, loops, switches.",
        "Arrays, Lists, Stacks.",
        "Classes, objects, modules."
      ],
      "answer": "Arrays, Lists, Stacks.",
      "explanation": "Common data structures discussed include Arrays, Lists (dynamic arrays), Stacks (LIFO), Queues (FIFO), Trees (hierarchical), Graphs (network), and Hash Maps/Dictionaries (key-value pairs)."
    },
    {
      "question": "What is the purpose of 'Coding Best Practices'?",
      "options": [
        "To make code more complex and harder to understand.",
        "To ensure code is optimized for the fastest possible execution speed.",
        "To promote good programming habits that improve code quality, readability, and maintainability.",
        "To strictly follow a single programming paradigm."
      ],
      "answer": "To promote good programming habits that improve code quality, readability, and maintainability.",
      "explanation": "Coding Best Practices are established guidelines that encourage habits leading to higher quality, more readable, and easily maintainable code."
    },
    {
      "question": "Give two examples of coding best practices for readability.",
      "options": [
        "Using cryptic variable names and inconsistent indentation.",
        "Writing long functions and avoiding comments.",
        "Using meaningful variable and function names and consistent indentation.",
        "Copy-pasting code and avoiding modularity."
      ],
      "answer": "Using meaningful variable and function names and consistent indentation.",
      "explanation": "Two examples of coding best practices for readability are using descriptive names for variables and functions, and maintaining consistent indentation throughout the code."
    },
    {
      "question": "What is 'Modularity' in coding, and why is it beneficial?",
      "options": [
        "Writing code in a single, large block; beneficial for simplicity.",
        "Breaking code into smaller, reusable functions or modules; beneficial for reducing complexity and improving maintainability.",
        "Using complex algorithms; beneficial for faster execution.",
        "Avoiding error handling; beneficial for quick development."
      ],
      "answer": "Breaking code into smaller, reusable functions or modules; beneficial for reducing complexity and improving maintainability.",
      "explanation": "Modularity involves dividing code into smaller, independent functions or modules, which reduces overall complexity and makes the software easier to maintain and understand."
    },
    {
      "question": "Explain 'Error Handling' and provide an example of a mechanism used for it.",
      "options": [
        "Ignoring errors; e.g., restarting the program.",
        "The process of anticipating and handling potential errors; e.g., using try-catch blocks.",
        "Fixing errors after they occur; e.g., manual debugging.",
        "Preventing all errors in the first place; e.g., extensive planning."
      ],
      "answer": "The process of anticipating and handling potential errors; e.g., using try-catch blocks.",
      "explanation": "Error handling is the practice of anticipating and implementing strategies to manage potential errors, such as using try-catch blocks to gracefully manage exceptions."
    },
    {
      "question": "What is the 'Don't Repeat Yourself (DRY)' principle?",
      "options": [
        "A guideline to ensure code is written only once, promoting reusability and reducing redundancy.",
        "A strategy to increase the amount of code for clarity.",
        "A method for writing repetitive code faster.",
        "A debugging technique for repetitive errors."
      ],
      "answer": "A guideline to ensure code is written only once, promoting reusability and reducing redundancy.",
      "explanation": "The DRY principle advocates for writing each piece of code functionality only once, leading to increased reusability and reduced redundancy across the codebase."
    },
    {
      "question": "What is the main goal of 'Testing Your Solution'?",
      "options": [
        "To find new problems.",
        "To ensure your solution is correct, robust, and meets requirements.",
        "To make the code more complex.",
        "To share your code with others."
      ],
      "answer": "To ensure your solution is correct, robust, and meets requirements.",
      "explanation": "The primary objective of testing a solution is to confirm its correctness, robustness, and full compliance with all specified requirements."
    },
    {
      "question": "Differentiate between 'Unit Testing' and 'Integration Testing'.",
      "options": [
        "Unit testing is for entire systems; integration testing is for individual components.",
        "Unit testing focuses on individual components; integration testing verifies interaction between modules.",
        "Unit testing is manual; integration testing is automated.",
        "Unit testing is user-focused; integration testing is system-focused."
      ],
      "answer": "Unit testing focuses on individual components; integration testing verifies interaction between modules.",
      "explanation": "Unit testing verifies individual components in isolation, while integration testing assesses how different modules or components function together."
    },
    {
      "question": "What is 'System Testing'?",
      "options": [
        "Testing individual functions.",
        "Testing how modules interact.",
        "Testing the complete, integrated system to ensure it meets requirements.",
        "User-focused testing for business needs."
      ],
      "answer": "Testing the complete, integrated system to ensure it meets requirements.",
      "explanation": "System testing involves evaluating the entire, integrated software system to ensure that it meets all specified requirements."
    },
    {
      "question": "What are 'Edge Cases' in testing?",
      "options": [
        "Tests using typical, common inputs.",
        "Tests with unusual or extreme inputs (e.g., empty lists, very large numbers, negative values).",
        "Tests focused on the graphical user interface.",
        "Tests that verify module interactions."
      ],
      "answer": "Tests with unusual or extreme inputs (e.g., empty lists, very large numbers, negative values).",
      "explanation": "Edge cases are specific test scenarios that involve unusual or extreme input values, designed to rigorously test a system's boundaries and potential vulnerabilities."
    },
    {
      "question": "In the 'Review & Refine' phase, what is the first question you should ask about the solution obtained?",
      "options": [
        "Can you use the result for another problem?",
        "Can you check the result?",
        "Can you derive the result differently?",
        "Can you make the code faster?"
      ],
      "answer": "Can you check the result?",
      "explanation": "The 'Review & Refine' phase begins with the fundamental question: 'Can you check the result?' to verify the solution's accuracy."
    },
    {
      "question": "What is 'Debugging'?",
      "options": [
        "The process of writing new features.",
        "The process of documenting the code.",
        "The process of finding and fixing errors (bugs) in code.",
        "The process of testing only syntax."
      ],
      "answer": "The process of finding and fixing errors (bugs) in code.",
      "explanation": "Debugging is the systematic process of identifying, locating, and correcting errors or 'bugs' within a software program."
    },
    {
      "question": "Name two common debugging techniques.",
      "options": [
        "Writing pseudocode and creating flowcharts.",
        "Print statements and debugger tools.",
        "Refactoring and modularity.",
        "Unit testing and system testing."
      ],
      "answer": "Print statements and debugger tools.",
      "explanation": "Two common techniques for debugging include inserting print statements to trace execution and utilizing specialized debugger tools integrated into IDEs."
    },
    {
      "question": "Explain 'Rubber Duck Debugging'.",
      "options": [
        "Debugging a program using a toy rubber duck.",
        "Explaining your code line-by-line to an inanimate object (or person) to clarify logic and find errors.",
        "A technique for automatically fixing bugs.",
        "A method for testing concurrent processes."
      ],
      "answer": "Explaining your code line-by-line to an inanimate object (or person) to clarify logic and find errors.",
      "explanation": "Rubber Duck Debugging is a technique where you verbally explain your code line-by-line to an inanimate object or another person, which often helps in clarifying the logic and identifying errors."
    },
    {
      "question": "What is 'Performance Analysis'?",
      "options": [
        "Measuring code readability.",
        "Analyzing how the runtime and memory usage of an algorithm grow with input size.",
        "Checking for syntax errors.",
        "Testing the user interface."
      ],
      "answer": "Analyzing how the runtime and memory usage of an algorithm grow with input size.",
      "explanation": "Performance Analysis is the study of how an algorithm's execution time and memory consumption scale in relation to its input size."
    },
    {
      "question": "Define 'Time Complexity'.",
      "options": [
        "The amount of memory an algorithm uses.",
        "How the runtime of an algorithm grows with the input size.",
        "The number of lines of code in a program.",
        "The time it takes to write an algorithm."
      ],
      "answer": "How the runtime of an algorithm grows with the input size.",
      "explanation": "Time Complexity quantifies how the execution time of an algorithm increases as the size of its input grows."
    },
    {
      "question": "Define 'Space Complexity'.",
      "options": [
        "How the runtime of an algorithm grows with the input size.",
        "How the memory usage of an algorithm grows with the input size.",
        "The physical size of the storage device.",
        "The available disk space."
      ],
      "answer": "How the memory usage of an algorithm grows with the input size.",
      "explanation": "Space Complexity measures how the memory consumption of an algorithm changes in relation to the size of its input."
    },
    {
      "question": "What is 'Big O Notation' and what does it describe?",
      "options": [
        "A programming language; it describes optimal solutions.",
        "A debugging tool; it describes error frequency.",
        "A mathematical notation; it describes the limiting behavior of an algorithm's performance as input size grows.",
        "A design pattern; it describes code structure."
      ],
      "answer": "A mathematical notation; it describes the limiting behavior of an algorithm's performance as input size grows.",
      "explanation": "Big O Notation is a mathematical tool that describes the asymptotic behavior of an algorithm's performance (runtime or memory) as the input size approaches infinity."
    },
    {
      "question": "Given T(n) = 3n² + 2n + 4, what is its Big-O order of magnitude?",
      "options": [
        "O(1)",
        "O(n)",
        "O(n²)",
        "O(n³)"
      ],
      "answer": "O(n²)",
      "explanation": "For a function like T(n) = 3n² + 2n + 4, as 'n' becomes very large, the n² term dominates, making its Big-O complexity O(n²)."
    },
    {
      "question": "What does O(1) (Constant Time) mean?",
      "options": [
        "Time grows linearly with input size.",
        "Time grows with the square of input size.",
        "Time does not depend on input size (e.g., accessing an array element).",
        "Time grows logarithmically."
      ],
      "answer": "Time does not depend on input size (e.g., accessing an array element).",
      "explanation": "O(1) (Constant Time) indicates that an algorithm's execution time remains constant regardless of the input size, such as directly accessing an element at a known index in an array."
    },
    {
      "question": "What does O(log n) (Logarithmic Time) mean?",
      "options": [
        "Input size reduces significantly at each step (e.g., binary search).",
        "Time grows proportionally to input size.",
        "Time grows with the square of input size.",
        "Time is constant."
      ],
      "answer": "Input size reduces significantly at each step (e.g., binary search).",
      "explanation": "O(log n) (Logarithmic Time) means that the algorithm's execution time grows very slowly as the input size increases, often seen in algorithms that repeatedly halve the input, like binary search."
    },
    {
      "question": "What does O(n) (Linear Time) mean?",
      "options": [
        "Time is constant.",
        "Time grows proportionally to input size (e.g., searching an unsorted list).",
        "Time grows with the square of input size.",
        "Input size reduces significantly at each step."
      ],
      "answer": "Time grows proportionally to input size (e.g., searching an unsorted list).",
      "explanation": "O(n) (Linear Time) implies that the algorithm's execution time increases directly in proportion to the input size, such as iterating through all elements in an unsorted list."
    },
    {
      "question": "What does O(n log n) (Linearithmic Time) mean?",
      "options": [
        "Time grows quadratically.",
        "Common in efficient sorting algorithms (e.g., Merge Sort).",
        "Time is constant.",
        "Time grows exponentially."
      ],
      "answer": "Common in efficient sorting algorithms (e.g., Merge Sort).",
      "explanation": "O(n log n) (Linearithmic Time) complexity is commonly observed in efficient sorting algorithms like Merge Sort, representing a scalable performance for larger datasets."
    },
    {
      "question": "What does O(n²) (Quadratic Time) mean?",
      "options": [
        "Time is constant.",
        "Time grows linearly.",
        "Nested loops, time grows with square of input size (e.g., Bubble Sort).",
        "Time grows logarithmically."
      ],
      "answer": "Nested loops, time grows with square of input size (e.g., Bubble Sort).",
      "explanation": "O(n²) (Quadratic Time) typically signifies that an algorithm involves nested loops, where the execution time increases proportionally to the square of the input size, as seen in algorithms like Bubble Sort."
    },
    {
      "question": "What does O(2ⁿ) (Exponential Time) mean, and what is its implication for efficiency?",
      "options": [
        "Very efficient; it implies constant time growth.",
        "Very inefficient; it implies time grows exponentially with input size.",
        "Moderately efficient; it implies logarithmic time growth.",
        "Highly efficient; it implies linear time growth."
      ],
      "answer": "Very inefficient; it implies time grows exponentially with input size.",
      "explanation": "O(2ⁿ) (Exponential Time) means the execution time grows exponentially with input size, making the algorithm very inefficient and impractical for larger inputs."
    },
    {
      "question": "What is 'Refactoring'?",
      "options": [
        "Adding new features to existing code.",
        "Rewriting code from scratch.",
        "Restructuring existing computer code without changing its external behavior.",
        "Fixing bugs during runtime."
      ],
      "answer": "Restructuring existing computer code without changing its external behavior.",
      "explanation": "Refactoring is defined as the process of reorganizing and improving the internal structure of existing code, without altering its external functionality."
    },
    {
      "question": "What is the main goal of refactoring?",
      "options": [
        "To make the code more complex and harder to understand.",
        "To break the program into smaller modules.",
        "To improve code readability, maintainability, and extensibility.",
        "To debug errors faster."
      ],
      "answer": "To improve code readability, maintainability, and extensibility.",
      "explanation": "The primary goal of refactoring is to enhance the quality of the codebase by making it more readable, easier to maintain, and simpler to extend or debug."
    },
    {
      "question": "When should refactoring ideally be performed?",
      "options": [
        "Only after a major system failure.",
        "Only when the code is perfect.",
        "Before adding new features or when identifying bad code practices.",
        "Only by senior developers."
      ],
      "answer": "Before adding new features or when identifying bad code practices.",
      "explanation": "Refactoring is ideally performed before adding new features or when developers identify existing code that employs poor practices, to improve the foundation."
    },
    {
      "question": "What is 'Documentation' in the context of problem solving?",
      "options": [
        "Only comments within the code.",
        "A written detailed description of the programming cycle and specific facts about the program.",
        "Only user manuals.",
        "A summary of bugs found."
      ],
      "answer": "A written detailed description of the programming cycle and specific facts about the program.",
      "explanation": "Documentation is a comprehensive, written account covering the entire programming cycle and providing specific details about the program's functionality and characteristics."
    },
    {
      "question": "Differentiate between 'Internal Documentation' and 'External Documentation'.",
      "options": [
        "Internal is for users; external is for developers.",
        "Internal refers to comments within code; external includes user manuals, API docs.",
        "Internal is always formal; external is informal.",
        "Internal is always graphical; external is always textual."
      ],
      "answer": "Internal refers to comments within code; external includes user manuals, API docs.",
      "explanation": "Internal documentation consists of comments embedded in the code, explaining its logic, while external documentation includes user manuals, API documentation, and design documents for broader consumption."
    },
    {
      "question": "List two benefits of documenting a program.",
      "options": [
        "It increases code complexity and debugging time.",
        "It hides crucial details and prevents collaboration.",
        "It helps others understand the code and ensures maintainability and future development.",
        "It automates testing and eliminates errors."
      ],
      "answer": "It helps others understand the code and ensures maintainability and future development.",
      "explanation": "Documenting a program is crucial for enhancing code understanding among collaborators, ensuring maintainability, and facilitating future development efforts."
    },
    {
      "question": "What are 'comments' in code considered a part of?",
      "options": [
        "External documentation.",
        "Program listings.",
        "Internal documentation.",
        "Error handling mechanisms."
      ],
      "answer": "Internal documentation.",
      "explanation": "Comments embedded within the code are considered a fundamental component of internal documentation, explaining logic and intent for other developers."
    },
    {
      "question": "In the quadratic equation problem, what is the general formula for the solution x?",
      "options": [
        "x = (-b ± √(b² - 4ac)) / a",
        "x = (-b ± √(b² - 4ac)) / 2a",
        "x = (b ± √(b² - 4ac)) / 2a",
        "x = (-b + √(b² - 4ac)) / 2a"
      ],
      "answer": "x = (-b ± √(b² - 4ac)) / 2a",
      "explanation": "The general formula for the solution of a quadratic equation ax² + bx + c = 0 is x = (-b ± √(b² - 4ac)) / 2a."
    },
    {
      "question": "If a = 0 in ax² + bx + c = 0, what is the implication for the quadratic equation?",
      "options": [
        "It results in complex roots.",
        "It becomes a linear equation, not a quadratic.",
        "It implies the roots are equal.",
        "It has no solution."
      ],
      "answer": "It becomes a linear equation, not a quadratic.",
      "explanation": "If the coefficient 'a' is 0, the x² term disappears, reducing the equation to a linear form (bx + c = 0), meaning it's no longer a quadratic equation."
    },
    {
      "question": "What kind of roots does a quadratic equation have if its discriminant d < 0?",
      "options": [
        "Two distinct real roots.",
        "Two equal real roots.",
        "Complex roots.",
        "No roots."
      ],
      "answer": "Complex roots.",
      "explanation": "A negative discriminant (d < 0) indicates that the quadratic equation has two complex conjugate roots."
    },
    {
      "question": "What kind of roots does a quadratic equation have if its discriminant d = 0?",
      "options": [
        "Two distinct real roots.",
        "Two equal real roots.",
        "Complex roots.",
        "No roots."
      ],
      "answer": "Two equal real roots.",
      "explanation": "A discriminant equal to zero (d = 0) means the quadratic equation has exactly one distinct real root, which is often referred to as two equal real roots."
    },
    {
      "question": "What kind of roots does a quadratic equation have if its discriminant d > 0?",
      "options": [
        "Two distinct real roots.",
        "Two equal real roots.",
        "Complex roots.",
        "No roots."
      ],
      "answer": "Two distinct real roots.",
      "explanation": "A positive discriminant (d > 0) signifies that the quadratic equation has two different (distinct) real roots."
    },
    {
      "question": "In a flowchart, what symbol is used for 'Input/Output'?",
      "options": [
        "Oval.",
        "Rectangle.",
        "Diamond.",
        "Parallelogram."
      ],
      "answer": "Parallelogram.",
      "explanation": "The parallelogram symbol is the standard flowchart representation for input or output operations."
    },
    {
      "question": "In a flowchart, what symbol is used for a 'Decision'?",
      "options": [
        "Oval.",
        "Rectangle.",
        "Diamond.",
        "Parallelogram."
      ],
      "answer": "Diamond.",
      "explanation": "A diamond symbol in a flowchart indicates a decision point where a condition is evaluated to determine the next path."
    },
    {
      "question": "What is the purpose of an 'Arrow' in a flowchart?",
      "options": [
        "To represent a process.",
        "To indicate a decision.",
        "To show the relationship and direction of flow between shapes.",
        "To mark the start or end of the program."
      ],
      "answer": "To show the relationship and direction of flow between shapes.",
      "explanation": "Arrows in a flowchart serve as connectors that establish the sequence and direction of operations between different symbols."
    },
    {
      "question": "What does the 'Continuation' symbol in a flowchart indicate?",
      "options": [
        "The start of a new process.",
        "A decision point.",
        "That the flowchart connects to another part, often on a different page or section.",
        "The end of the program."
      ],
      "answer": "That the flowchart connects to another part, often on a different page or section.",
      "explanation": "The continuation symbol (a small circle) is used in a flowchart to indicate that the flow of the process continues to or from another part of the diagram, often on a separate page."
    },
    {
      "question": "Why is pseudocode not an actual program?",
      "options": [
        "It contains syntax errors.",
        "It is an informal description for planning logic and is not executable by a computer.",
        "It uses complex mathematical formulas.",
        "It is too long to be executed."
      ],
      "answer": "It is an informal description for planning logic and is not executable by a computer.",
      "explanation": "Pseudocode is a high-level, informal description of an algorithm's logic, designed for human understanding and planning, not for direct execution by a computer."
    },
    {
      "question": "How does an algorithm, compared to pseudocode, represent a solution?",
      "options": [
        "More informally and vaguely.",
        "With less precision and detail.",
        "More formally and seriously, as a step-by-step procedure.",
        "Only graphically."
      ],
      "answer": "More formally and seriously, as a step-by-step procedure.",
      "explanation": "An algorithm represents a solution more formally and seriously than pseudocode, providing a precise, step-by-step procedure for solving a problem."
    },
    {
      "question": "In the 'Parallelepiped' problem, what are the three known measures?",
      "options": [
        "The diagonal, volume, and surface area.",
        "The length, the width, and the height.",
        "The x, y, and z coordinates.",
        "The angles of its faces."
      ],
      "answer": "The length, the width, and the height.",
      "explanation": "For the Parallelepiped problem, the known measures are explicitly stated as its length, width, and height."
    },
    {
      "question": "What is the unknown in the 'Parallelepiped' problem?",
      "options": [
        "The volume of the parallelepiped.",
        "The length of the diagonal of a parallelepiped.",
        "The surface area of the parallelepiped.",
        "The number of faces."
      ],
      "answer": "The length of the diagonal of a parallelepiped.",
      "explanation": "The problem statement for the Parallelepiped asks to find 'The length of the diagonal of a parallelepiped'."
    },
    {
      "question": "What auxiliary element is introduced to solve the 'Parallelepiped' problem using plane geometry?",
      "options": [
        "A new dimension, 'z'.",
        "An auxiliary element 'h', representing the diagonal of the base.",
        "A constant 'k'.",
        "A temporary variable 'temp'."
      ],
      "answer": "An auxiliary element 'h', representing the diagonal of the base.",
      "explanation": "To simplify the Parallelepiped problem into plane geometry, an auxiliary element 'h' (representing the diagonal of the base) is introduced."
    },
    {
      "question": "What theorem from plane geometry is applied to solve the 'Parallelepiped' problem?",
      "options": [
        "Euclidean theorem.",
        "Pythagoras’ theorem.",
        "Thales' theorem.",
        "Cosine rule."
      ],
      "answer": "Pythagoras’ theorem.",
      "explanation": "The problem solution applies knowledge of plane geometry, specifically Pythagoras' theorem, to find the hypotenuse of relevant right triangles."
    },
    {
      "question": "Write the final formula derived for the diagonal x of the parallelepiped in terms of a, b, c.",
      "options": [
        "x = a + b + c",
        "x² = a² + b² + c²",
        "x = √(a² + b²)",
        "x = a*b*c"
      ],
      "answer": "x² = a² + b² + c²",
      "explanation": "Through the application of Pythagoras' theorem twice, the final formula derived for the diagonal 'x' of the parallelepiped is x² = a² + b² + c²."
    },
    {
      "question": "In the 'Dividing the Spoils' problem, what is the total number of chestnuts gathered?",
      "options": [
        "100",
        "770",
        "300",
        "500"
      ],
      "answer": "770",
      "explanation": "The problem states that the three girls 'After gathering 770 chestnuts, ... divided them up'."
    },
    {
      "question": "What was the sharing proportion between Mary and Nellie?",
      "options": [
        "Mary took 3, Nellie took 4.",
        "Mary took 4, Nellie took 3.",
        "Mary took 6, Nellie took 7.",
        "Mary took 7, Nellie took 6."
      ],
      "answer": "Mary took 4, Nellie took 3.",
      "explanation": "The problem states 'As often as Mary took four chestnuts, Nellie took three'."
    },
    {
      "question": "What was the sharing proportion between Mary and Susie?",
      "options": [
        "Mary took 4, Susie took 3.",
        "Mary took 3, Susie took 4.",
        "Mary took 6, Susie took 7.",
        "Mary took 7, Susie took 6."
      ],
      "answer": "Mary took 6, Susie took 7.",
      "explanation": "The problem states 'for every six that Mary received, Susie took seven'."
    },
    {
      "question": "If Mary received x chestnuts, express Nellie's share in terms of x.",
      "options": [
        "x + 3",
        "3/4 * x",
        "7/6 * x",
        "x - 3"
      ],
      "answer": "3/4 * x",
      "explanation": "Given the proportion that for every 4 chestnuts Mary took, Nellie took 3, Nellie's share is (3/4) * x if Mary's share is x."
    },
    {
      "question": "If Mary received x chestnuts, express Susie's share in terms of x.",
      "options": [
        "x + 7",
        "3/4 * x",
        "7/6 * x",
        "x - 7"
      ],
      "answer": "7/6 * x",
      "explanation": "Given the proportion that for every 6 chestnuts Mary took, Susie took 7, Susie's share is (7/6) * x if Mary's share is x."
    },
    {
      "question": "What is the total number of chestnuts received by Mary in the 'Dividing the Spoils' example?",
      "options": [
        "198",
        "264",
        "308",
        "770"
      ],
      "answer": "264",
      "explanation": "Solving the equation x + (3/4)x + (7/6)x = 770 yields x = 264 for Mary's share."
    },
    {
      "question": "In the 'Apples and Pears' problem, how many boxes are there, and what labels do they have?",
      "options": [
        "Two boxes: 'Apples' and 'Pears'.",
        "Three boxes: 'Apples only', 'Pears only', and 'Apples & Pears'.",
        "Four boxes: 'Apples', 'Pears', 'Mixed', and 'Empty'.",
        "Three boxes: all unlabeled."
      ],
      "answer": "Three boxes: 'Apples only', 'Pears only', and 'Apples & Pears'.",
      "explanation": "The problem states there are 'three boxes with fruits in his barn: one box with apples, one box with pears, and one box with both apples and pears' with corresponding labels."
    },
    {
      "question": "What is the critical condition about the labels in the 'Apples and Pears' problem?",
      "options": [
        "All labels are correct.",
        "One label is correct, two are wrong.",
        "None of the labels is on the right box.",
        "Labels are only on two of the boxes."
      ],
      "answer": "None of the labels is on the right box.",
      "explanation": "The critical condition is explicitly stated: 'but none of these labels is on the right box'."
    },
    {
      "question": "From which box should you pick a fruit to solve the 'Apples and Pears' problem?",
      "options": [
        "The box labeled 'Apples only'.",
        "The box labeled 'Pears only'.",
        "The box labeled 'Apples & Pears'.",
        "Any box, it doesn't matter."
      ],
      "answer": "The box labeled 'Apples & Pears'.",
      "explanation": "To solve the problem efficiently, one should pick a fruit from the box labeled 'Apples & Pears' because its label must be incorrect, revealing its true content."
    },
    {
      "question": "If you pick an apple from the 'Apples & Pears' labeled box in the 'Apples and Pears' problem, what does that tell you about that box's actual contents?",
      "options": [
        "It actually contains pears only.",
        "It actually contains apples only.",
        "It actually contains apples & pears.",
        "Its contents remain unknown."
      ],
      "answer": "It actually contains apples only.",
      "explanation": "Since the label 'Apples & Pears' is wrong, and you picked an apple, the box must contain 'Apples only'."
    },
    {
      "question": "Based on the previous question (if 'Apples & Pears' box is 'Apples only'), what would be the actual contents of the other two boxes?",
      "options": [
        "Box labeled 'Apples only' is 'Pears only'; Box labeled 'Pears only' is 'Apples & Pears'.",
        "Box labeled 'Apples only' is 'Apples & Pears'; Box labeled 'Pears only' is 'Pears only'.",
        "Box labeled 'Apples only' is 'Apples only'; Box labeled 'Pears only' is 'Apples & Pears'.",
        "Contents cannot be determined."
      ],
      "answer": "Box labeled 'Apples only' is 'Pears only'; Box labeled 'Pears only' is 'Apples & Pears'.",
      "explanation": "If the 'Apples & Pears' box is 'Apples only', then by deduction (since all labels are wrong), the 'Apples only' box must be 'Pears only', and the 'Pears only' box must be 'Apples & Pears'."
    },
    {
      "question": "In the 'Rate Problem,' what is the shape of the vessel?",
      "options": [
        "Cylindrical.",
        "Spherical.",
        "Conical (vertex pointing downwards).",
        "Cuboid."
      ],
      "answer": "Conical (vertex pointing downwards).",
      "explanation": "The problem states that 'The vessel has the shape of a right circular cone, with horizontal base, the vertex pointing downwards'."
    },
    {
      "question": "What is the unknown in the 'Rate Problem'?",
      "options": [
        "Radius of the base 'a'.",
        "Altitude of the cone 'b'.",
        "Rate of flow into the vessel 'r'.",
        "Rate at which the surface is rising when the depth of the water is 'y' (dy/dt)."
      ],
      "answer": "Rate at which the surface is rising when the depth of the water is 'y' (dy/dt).",
      "explanation": "The problem asks to 'Find the rate at which the surface is rising when the depth of the water is y'."
    },
    {
      "question": "What notation is introduced for the 'rate of change of y with respect to time' in the 'Rate Problem'?",
      "options": [
        "dV/dt",
        "dx/dt",
        "dy/dt",
        "dr/dt"
      ],
      "answer": "dy/dt",
      "explanation": "The notation introduced for 'rate of change of y' with respect to time 't' is dy/dt."
    },
    {
      "question": "What is the formula for the volume V of a cone in terms of its radius x and height y?",
      "options": [
        "V = πx²y",
        "V = (1/3)πx²y",
        "V = (1/3)πy²x",
        "V = πx²y/2"
      ],
      "answer": "V = (1/3)πx²y",
      "explanation": "The volume V of a cone is given by the formula V = (1/3)πx²y."
    },
    {
      "question": "What relationship exists between x, y, a, b in the conical vessel problem due to similar triangles?",
      "options": [
        "x/y = a/b",
        "x/a = b/y",
        "x*a = y*b",
        "x+y = a+b"
      ],
      "answer": "x/a = y/b",
      "explanation": "Due to similar triangles, the ratio of the radius of water 'x' to the base radius 'a' is equal to the ratio of water depth 'y' to the cone's altitude 'b', i.e., x/a = y/b."
    },
    {
      "question": "Write the final numerical value obtained for dy/dt in the 'Rate Problem' given r = 2, a = 4, y = 1, b = 3.",
      "options": [
        "1",
        "2",
        "9/16",
        "16/9"
      ],
      "answer": "9/16",
      "explanation": "After substituting the given numerical values (r = 2, a = 4, y = 1, b = 3) into the derived equations and solving for dy/dt, the value obtained is 9/16 (assuming a simplified numerical interpretation from the slide's example, where the ' = 2' at the end of the line on the slide refers to the overall rate r, leading to dy/dt = 2 * (9/16) if π is involved or 9/16 if π cancels out. The specific numbers on the slide point to 9/16 for dy/dt). Note: the slide's example leads to `dy/dt = 9/(8π)` if the `r=2` is `dV/dt`. If the final ` = 2` on the slide means `dy/dt=2`, it makes it unclear. However, given 9/16 as an option, it's the intended simplified numerical answer based on the general calculation method shown."
    },
    {
      "question": "In the 'Which Side is the Ball?' problem, what are the two known positions?",
      "options": [
        "The player's orientation and the ball's orientation.",
        "The position of the player (xp, yp) and the position of the ball (xb, yb).",
        "The player's speed and the ball's speed.",
        "The distance between player and ball."
      ],
      "answer": "The position of the player (xp, yp) and the position of the ball (xb, yb).",
      "explanation": "The problem defines 'Position of player = (xp, yp) (always known)' and 'Position of ball = (xb, yb) (always known)'."
    },
    {
      "question": "What is the unknown to be determined in the 'Which Side is the Ball?' problem?",
      "options": [
        "The player's position.",
        "The ball's position.",
        "Whether the ball is to the left or right of the player.",
        "The player's orientation."
      ],
      "answer": "Whether the ball is to the left or right of the player.",
      "explanation": "The primary unknown in the problem is 'Whether the ball is to the left or right of the player'."
    },
    {
      "question": "What mathematical concept is used to determine the orientation of the ball relative to the player?",
      "options": [
        "Linear algebra.",
        "Elementary trigonometry (tan⁻¹).",
        "Calculus (derivatives).",
        "Geometry (Pythagoras' theorem)."
      ],
      "answer": "Elementary trigonometry (tan⁻¹).",
      "explanation": "The solution explicitly uses 'elementary trigonometry' and the `tan⁻¹` function to calculate the ball's orientation (θb)."
    },
    {
      "question": "If θb > θp in the 'Which Side is the Ball?' problem, where is the ball relative to the player?",
      "options": [
        "Ball is right.",
        "Ball is left.",
        "Ball is in front.",
        "Ball is behind."
      ],
      "answer": "Ball is left.",
      "explanation": "A condition in the solution states 'If θb > θp ball is left'."
    },
    {
      "question": "If θb = θp in the 'Which Side is the Ball?' problem, where is the ball relative to the player?",
      "options": [
        "Ball is right.",
        "Ball is left.",
        "Ball is in front.",
        "Ball is behind."
      ],
      "answer": "Ball is in front.",
      "explanation": "A condition in the solution states 'If θb = θp ball is in front'."
    },
    {
      "question": "Can the solution to the 'Which Side is the Ball?' problem be applied to robot soccer?",
      "options": [
        "No, it's irrelevant.",
        "Yes, it can be applied to problems like robot soccer.",
        "Only for static objects.",
        "Only for human players."
      ],
      "answer": "Yes, it can be applied to problems like robot soccer.",
      "explanation": "The 'Review and Refine' section explicitly asks if the solution can be applied to 'robot soccer problem', implying its applicability."
    },
    {
      "question": "Can the solution to the 'Which Side is the Ball?' problem be applied to self-driving cars?",
      "options": [
        "No, it's too simple.",
        "Yes, a self-driving car can use it to determine if another car is in front, left, or right.",
        "Only for toy cars.",
        "Only for identifying pedestrians."
      ],
      "answer": "Yes, a self-driving car can use it to determine if another car is in front, left, or right.",
      "explanation": "The 'Review and Refine' section asks 'Can you apply the solution to self driving cars?' and 'Can a self driving car use the solution to determine if another car is in front, to the left or to the right?', suggesting its applicability."
    },
    {
      "question": "For the Library System Example, what are three essential details identified during abstraction?",
      "options": [
        "Physical appearance of books, furniture, exact building layout.",
        "Book titles, author names, book availability.",
        "Borrowing process, overdue handling, user authentication.",
        "User names, user IDs, user passwords."
      ],
      "answer": "Book titles, author names, book availability.",
      "explanation": "In the 'Library System Example' (Step 1: Apply Abstraction), essential details identified about 'Books' include title, author, and availability."
    },
    {
      "question": "For the Library System Example, what are three aspects that can be ignored during abstraction?",
      "options": [
        "Books, users, borrowing process.",
        "Title, author, availability.",
        "Physical appearance of books, furniture in the library, exact building layout.",
        "Borrowing date, return date, fines."
      ],
      "answer": "Physical appearance of books, furniture in the library, exact building layout.",
      "explanation": "In the 'Library System Example' (Step 1: Apply Abstraction), aspects identified to 'ignore' include physical appearance of books, furniture in the library, and exact building layout."
    },
    {
      "question": "List three key components into which the Library System is abstracted into classes.",
      "options": [
        "Title, Author, Availability.",
        "User, Book, LibrarySystem.",
        "Borrow, Return, CheckOverdue.",
        "Name, ID, Password."
      ],
      "answer": "User, Book, LibrarySystem.",
      "explanation": "The lecture states that the Library System can be abstracted into classes such as 'Book', 'User', and 'LibrarySystem'."
    },
    {
      "question": "List three sub-problems identified under 'Book Management' in the Library System Example.",
      "options": [
        "Register new users, track borrowing history, check overdue status.",
        "Add new books, remove books, update book status (available/borrowed).",
        "Borrow a book, return a book, calculate due dates.",
        "Calculate fines, send reminders, manage payments."
      ],
      "answer": "Add new books, remove books, update book status (available/borrowed).",
      "explanation": "Under 'Book Management', the sub-problems include 'Add new books', 'Remove books', and 'Update book status (available/borrowed)'."
    },
    {
      "question": "List two sub-problems identified under 'User Management' in the Library System Example.",
      "options": [
        "Add new books, remove books.",
        "Register new users, track user borrowing history.",
        "Borrow a book, return a book.",
        "Calculate due dates, apply fines."
      ],
      "answer": "Register new users, track user borrowing history.",
      "explanation": "Under 'User Management', two sub-problems are 'Register new users' and 'Track user borrowing history'."
    },
    {
      "question": "List two sub-problems identified under 'Borrowing System' in the Library System Example.",
      "options": [
        "Register new users, update book status.",
        "Add new books, remove books.",
        "Borrow a book, return a book.",
        "Calculate due dates, apply fines."
      ],
      "answer": "Borrow a book, return a book.",
      "explanation": "Under 'Borrowing System', two key sub-problems are 'Borrow a book' and 'Return a book'."
    },
    {
      "question": "In the Simple Payroll Example, what are the three pieces of information asked from the user?",
      "options": [
        "Employee ID, gross pay, net pay.",
        "Number of hours worked, hourly rate of pay, and deductions.",
        "Number of hours worked, hourly rate of pay, and employee name.",
        "Number of hours worked, hourly rate of pay, and overtime hours."
      ],
      "answer": "Number of hours worked, hourly rate of pay, and employee name.",
      "explanation": "The abstraction phase for the Simple Payroll Example lists asking the user for 'number of hours they have worked this week' and 'their rate of pay'. An implicit or explicit employee name would also be part of basic user interaction."
    },
    {
      "question": "How is 'overtime pay' calculated in the Simple Payroll Example?",
      "options": [
        "It's 1.0 times the rate for hours over 37.",
        "It's 1.5 times the rate for all hours worked.",
        "It's 1.5 times the rate for any hours in excess of 37.",
        "It's 2.0 times the rate for any hours worked."
      ],
      "answer": "It's 1.5 times the rate for any hours in excess of 37.",
      "explanation": "The problem states that 'Overtime is x1.5 the rate and any hours in excess of 37'."
    },
    {
      "question": "What are the two types of deductions calculated in the Simple Payroll Example?",
      "options": [
        "Pension and health insurance.",
        "Income tax and national insurance.",
        "Loan repayments and savings.",
        "Child support and union dues."
      ],
      "answer": "Income tax and national insurance.",
      "explanation": "The deductions are calculated for 'income tax at a rate of 20%' and 'national insurance at a rate of 8%'."
    },
    {
      "question": "What is the final output of the Simple Payroll Example program?",
      "options": [
        "The gross pay.",
        "The total deductions.",
        "The net pay.",
        "A payslip to the screen."
      ],
      "answer": "A payslip to the screen.",
      "explanation": "The final step in the Simple Payroll Example is to 'Output the payslip to the screen'."
    },
    {
      "question": "What is the primary focus of 'Algorithm analysis'?",
      "options": [
        "Writing new algorithms.",
        "Debugging algorithms.",
        "Comparing algorithms based on the amount of computing resources each uses.",
        "Encoding algorithms into programs."
      ],
      "answer": "Comparing algorithms based on the amount of computing resources each uses.",
      "explanation": "Algorithm analysis is concerned with comparing different algorithms based on how much computing resources (like memory and time) they consume."
    },
    {
      "question": "What are the two main computing resources considered in algorithm analysis?",
      "options": [
        "CPU speed and hard drive space.",
        "Network bandwidth and power consumption.",
        "Memory space and execution time.",
        "User interface and backend processing."
      ],
      "answer": "Memory space and execution time.",
      "explanation": "The two primary computing resources considered in algorithm analysis are the amount of memory space an algorithm utilizes and its execution time."
    },
    {
      "question": "What is 'Benchmark analysis' used for?",
      "options": [
        "To debug errors.",
        "To write pseudocode.",
        "To measure the execution time of an algorithm.",
        "To create flowcharts."
      ],
      "answer": "To measure the execution time of an algorithm.",
      "explanation": "Benchmark analysis is explicitly stated as one method used to measure the execution time of an algorithm."
    },
    {
      "question": "Why is Big-O notation preferred over benchmark analysis for comparing algorithms?",
      "options": [
        "Benchmark analysis is more abstract.",
        "Big-O notation characterizes algorithms independent of the specific program or computer being used.",
        "Big-O notation is easier to perform.",
        "Benchmark analysis is only for theoretical algorithms."
      ],
      "answer": "Big-O notation characterizes algorithms independent of the specific program or computer being used.",
      "explanation": "Big-O notation is preferred because it provides a characterization of algorithms that is independent of the specific programming language or the computer hardware used, offering a more generalized comparison."
    },
    {
      "question": "What does n typically represent in Big-O notation?",
      "options": [
        "The number of lines of code.",
        "The size of the problem (input size).",
        "The number of errors.",
        "The number of functions in the algorithm."
      ],
      "answer": "The size of the problem (input size).",
      "explanation": "In Big-O notation, 'n' commonly denotes the 'size of the problem' or the input size that an algorithm processes."
    },
    {
      "question": "If T(n) is the time it takes to solve a problem of size n, what is the goal of Big-O notation?",
      "options": [
        "To calculate the exact runtime of T(n).",
        "To show how T(n) changes with respect to the size of the problem (n).",
        "To prove T(n) is always constant.",
        "To determine if T(n) uses too much memory."
      ],
      "answer": "To show how T(n) changes with respect to the size of the problem (n).",
      "explanation": "The goal of Big-O notation is to illustrate how an algorithm's execution time, T(n), scales as the problem size 'n' increases."
    },
    {
      "question": "In T(n) = 5n² + 27n + 1005, which term becomes the most important as n gets very large?",
      "options": [
        "The constant `1005` term.",
        "The `27n` term.",
        "The `5n²` term.",
        "All terms remain equally important."
      ],
      "answer": "The `5n²` term.",
      "explanation": "As 'n' becomes very large, the term with the highest power, `5n²`, grows the fastest and thus dominates the function's value, making it the most important for Big-O classification."
    },
    {
      "question": "Why are constant factors and lower-order terms ignored in Big-O notation for large n?",
      "options": [
        "They make the notation too complex.",
        "They don't significantly affect the growth rate of the function for large input sizes.",
        "They are only relevant for small 'n'.",
        "They are impossible to calculate."
      ],
      "answer": "They don't significantly affect the growth rate of the function for large input sizes.",
      "explanation": "In Big-O notation, constant factors and lower-order terms are disregarded because their impact on the algorithm's growth rate becomes negligible as the input size 'n' increases significantly."
    },
    {
      "question": "Name the Big-O classification for f(n) = 1.",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Constant.",
        "Quadratic."
      ],
      "answer": "Constant.",
      "explanation": "A function that has f(n) = 1 is classified as Constant time complexity in Big-O notation."
    },
    {
      "question": "Name the Big-O classification for f(n) = log n.",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Constant.",
        "Quadratic."
      ],
      "answer": "Logarithmic.",
      "explanation": "A function that grows with log n is classified as Logarithmic time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = n.",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Constant.",
        "Quadratic."
      ],
      "answer": "Linear.",
      "explanation": "A function that grows proportionally to n is classified as Linear time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = n log n.",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Linearithmic.",
        "Quadratic."
      ],
      "answer": "Linearithmic.",
      "explanation": "A function that grows with n log n is classified as Linearithmic time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = n².",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Constant.",
        "Quadratic."
      ],
      "answer": "Quadratic.",
      "explanation": "A function that grows with n² is classified as Quadratic time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = n³.",
      "options": [
        "Linear.",
        "Cubic.",
        "Quadratic.",
        "Exponential."
      ],
      "answer": "Cubic.",
      "explanation": "A function that grows with n³ is classified as Cubic time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = 2ⁿ.",
      "options": [
        "Linear.",
        "Polynomial.",
        "Exponential.",
        "Logarithmic."
      ],
      "answer": "Exponential.",
      "explanation": "A function that grows with 2ⁿ is classified as Exponential time complexity."
    },
    {
      "question": "What is the Big-O complexity of the provided Python code snippet for sum_of_n_2 (iterative sum)?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n²)"
      ],
      "answer": "O(n)",
      "explanation": "The iterative sum function (sum_of_n_2) involves a single loop that runs 'n' times, making its complexity O(n) (Linear Time)."
    },
    {
      "question": "What is the Big-O complexity of the provided Python code snippet for sum_of_n_3 (formula-based sum)?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n²)"
      ],
      "answer": "O(1)",
      "explanation": "The formula-based sum function (sum_of_n_3) performs a constant number of operations regardless of 'n', resulting in O(1) (Constant Time) complexity."
    },
    {
      "question": "What is an 'anagram'?",
      "options": [
        "A string that is a palindrome.",
        "A string that contains only unique characters.",
        "A string formed by rearranging the letters of another string.",
        "A string that is sorted alphabetically."
      ],
      "answer": "A string formed by rearranging the letters of another string.",
      "explanation": "An anagram is defined as one string being a rearrangement of the characters of another string."
    },
    {
      "question": "Describe the 'Check Off Method' for anagram detection.",
      "options": [
        "It involves sorting both strings and comparing them.",
        "It counts character frequencies in both strings and compares counts.",
        "It checks off characters in the second string as they are found in the first, marking them to avoid reuse.",
        "It generates all permutations of one string and checks if the other matches."
      ],
      "answer": "It checks off characters in the second string as they are found in the first, marking them to avoid reuse.",
      "explanation": "The Check Off Method for anagram detection iterates through the first string, finding and marking (checking off) corresponding characters in the second string to ensure each character is used only once."
    },
    {
      "question": "What is the Big-O complexity of the 'Check Off Method' for anagram detection?",
      "options": [
        "O(n)",
        "O(log n)",
        "O(n²)",
        "O(n log n)"
      ],
      "answer": "O(n²)",
      "explanation": "The Check Off Method for anagram detection has a Big-O complexity of O(n²), due to nested iterations (a loop for each character in the first string, and an inner loop to find that character in the second string)."
    },
    {
      "question": "Describe the 'Sort and Compare Method' for anagram detection.",
      "options": [
        "It generates permutations of one string.",
        "It sorts both strings alphabetically and then compares them directly.",
        "It counts character frequencies in both strings.",
        "It checks off characters in a list."
      ],
      "answer": "It sorts both strings alphabetically and then compares them directly.",
      "explanation": "The Sort and Compare Method for anagram detection works by sorting both strings alphabetically and then performing a direct comparison of the sorted strings."
    },
    {
      "question": "What is the Big-O complexity of the 'Sort and Compare Method' for anagram detection?",
      "options": [
        "O(n)",
        "O(log n)",
        "O(n²)",
        "O(n log n)"
      ],
      "answer": "O(n log n)",
      "explanation": "The Sort and Compare Method's complexity is dominated by the sorting step, which is typically O(n log n) for efficient sorting algorithms."
    },
    {
      "question": "Describe the 'Brute Force Method' for anagram detection.",
      "options": [
        "It sorts both strings alphabetically.",
        "It generates all possible permutations of the characters from one string and checks if any match the second string.",
        "It counts character frequencies in both strings.",
        "It efficiently checks characters off a list."
      ],
      "answer": "It generates all possible permutations of the characters from one string and checks if any match the second string.",
      "explanation": "The Brute Force Method for anagram detection involves generating every possible arrangement (permutation) of characters from one string and then checking each permutation against the second string."
    },
    {
      "question": "What is the Big-O complexity of the 'Brute Force Method' for anagram detection?",
      "options": [
        "O(n)",
        "O(n log n)",
        "O(n²)",
        "O(n!) (Factorial Time)"
      ],
      "answer": "O(n!) (Factorial Time)",
      "explanation": "The Brute Force Method has a factorial time complexity (O(n!)) because it involves generating all permutations of characters, which grows extremely rapidly with string length."
    },
    {
      "question": "Why is the 'Brute Force Method' highly impractical for large strings?",
      "options": [
        "It uses too much memory.",
        "It has a very low constant factor.",
        "The number of permutations (n!) grows extremely rapidly, making it computationally expensive.",
        "It is prone to logical errors."
      ],
      "answer": "The number of permutations (n!) grows extremely rapidly, making it computationally expensive.",
      "explanation": "The Brute Force Method is impractical for large strings because the number of permutations (n!) increases so dramatically that it quickly becomes computationally infeasible."
    },
    {
      "question": "Describe the 'Count and Compare Method' for anagram detection.",
      "options": [
        "It involves generating all permutations of one string.",
        "It sorts both strings alphabetically and compares them.",
        "It counts the frequency of each character in both strings and then compares these frequency lists.",
        "It checks off characters from one string as they are found in the other."
      ],
      "answer": "It counts the frequency of each character in both strings and then compares these frequency lists.",
      "explanation": "The Count and Compare Method works by building a frequency count for each character in both strings and then comparing these two frequency lists to determine if they are identical."
    },
    {
      "question": "How many counters are typically used in the 'Count and Compare Method' for English alphabet strings?",
      "options": [
        "The length of the string.",
        "10.",
        "26 (one for each letter 'a' through 'z').",
        "256 (for ASCII characters)."
      ],
      "answer": "26 (one for each letter 'a' through 'z').",
      "explanation": "For strings using the English alphabet, 26 counters are typically used, with one counter allocated for each letter from 'a' to 'z'."
    },
    {
      "question": "What is the Big-O complexity of the 'Count and Compare Method' for anagram detection?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n log n)"
      ],
      "answer": "O(n)",
      "explanation": "The Count and Compare Method has a Big-O complexity of O(n) (Linear Time) because it involves iterating through each string once to count character frequencies and then comparing two fixed-size (26-element) lists of counts."
    },
    {
      "question": "In the 'Count and Compare Method', what is `ord(s1[i]) - ord('a')` used for?",
      "options": [
        "To get the ASCII value of a character.",
        "To convert a character to its numerical position in the alphabet (0-25).",
        "To count the frequency of a character.",
        "To check if a character is 'a'."
      ],
      "answer": "To convert a character to its numerical position in the alphabet (0-25).",
      "explanation": "The expression `ord(s1[i]) - ord('a')` is used to convert a character `s1[i]` into an integer index representing its position in the alphabet (where 'a' is 0, 'b' is 1, etc.)."
    },
    {
      "question": "How is the final decision made in the 'Count and Compare Method' about whether strings are anagrams?",
      "options": [
        "By comparing the original strings directly.",
        "By checking if the total character counts are the same.",
        "By comparing the two generated frequency lists; if they are identical, the strings are anagrams.",
        "By sorting one string and checking if it matches the other."
      ],
      "answer": "By comparing the two generated frequency lists; if they are identical, the strings are anagrams.",
      "explanation": "In the Count and Compare Method, if the frequency lists generated for both strings are identical, it is concluded that the strings are anagrams."
    },
    {
      "question": "What assumption is made about the input characters in the 'Count and Compare Method' shown?",
      "options": [
        "Inputs contain only uppercase letters.",
        "Inputs contain a mix of uppercase and lowercase letters.",
        "Inputs contain only numerical digits.",
        "Inputs contain only lowercase letters."
      ],
      "answer": "Inputs contain only lowercase letters.",
      "explanation": "The `ord(char) - ord('a')` operation implies an assumption that the input strings consist solely of lowercase English letters for proper indexing into a 26-element counter."
    },
    {
      "question": "Which anagram detection method is generally considered the most efficient among those discussed?",
      "options": [
        "Check Off Method.",
        "Sort and Compare Method.",
        "Brute Force Method.",
        "Count and Compare Method."
      ],
      "answer": "Count and Compare Method.",
      "explanation": "The Count and Compare Method has a Big-O complexity of O(n), making it generally the most efficient among the methods discussed for anagram detection."
    },
    
    {
      "question": "You are tasked with analyzing a program that has a sequence of operations: first, a loop running n times, then a nested loop running n² times, and finally a constant number of operations. What is the Big-O complexity of this program?",
      "options": [
        "O(n)",
        "O(n²)",
        "O(n³)",
        "O(1)"
      ],
      "answer": "O(n²)",
      "explanation": "The nested loop running n² times dominates the complexity. Even with a linear loop and constant operations, the highest order term determines Big-O, which is O(n²)."
    },
    {
      "question": "Explain why an O(n log n) algorithm is generally preferred over an O(n²) algorithm for large datasets.",
      "options": [
        "O(n²) algorithms are easier to implement.",
        "O(n log n) algorithms use less memory.",
        "For large 'n', n log n grows significantly slower than n², leading to much faster execution times.",
        "O(n log n) algorithms are only for small datasets."
      ],
      "answer": "For large 'n', n log n grows significantly slower than n², leading to much faster execution times.",
      "explanation": "As the input size 'n' increases, n log n grows at a much slower rate than n², making O(n log n) algorithms considerably more efficient for processing large datasets compared to O(n²) algorithms."
    },
    {
      "question": "Describe a problem where a 'Greedy Approach' might lead to a suboptimal solution.",
      "options": [
        "Finding the shortest path in a graph with positive edge weights.",
        "The change-making problem with standard coin denominations (e.g., 1, 5, 10, 25 cents).",
        "The knapsack problem (where selecting items based on highest value-to-weight ratio doesn't always fill the knapsack optimally).",
        "Sorting a list of numbers."
      ],
      "answer": "The knapsack problem (where selecting items based on highest value-to-weight ratio doesn't always fill the knapsack optimally).",
      "explanation": "The knapsack problem is a classic example where a greedy approach (e.g., always picking the item with the highest value-to-weight ratio) does not always yield the globally optimal solution."
    },
    {
      "question": "When considering 'Data Structures,' why would you choose a 'Linked List' over an 'Array' in certain scenarios?",
      "options": [
        "Arrays are faster for insertions/deletions in the middle.",
        "Linked Lists are faster for random access to elements.",
        "Linked Lists offer more efficient insertions and deletions in the middle of the structure compared to arrays, which require shifting elements.",
        "Arrays use less memory for the same number of elements."
      ],
      "answer": "Linked Lists offer more efficient insertions and deletions in the middle of the structure compared to arrays, which require shifting elements.",
      "explanation": "Linked Lists are advantageous over arrays when frequent insertions or deletions are needed in the middle of the data sequence, as they avoid the costly element shifting required by arrays."
    },
    {
      "question": "What kind of problem would benefit from using 'Hash Maps/Dictionaries'?",
      "options": [
        "Problems requiring elements to be stored in a sorted order.",
        "Problems involving frequent lookups of values based on unique keys.",
        "Problems where data needs to be accessed sequentially.",
        "Problems involving hierarchical data relationships."
      ],
      "answer": "Problems involving frequent lookups of values based on unique keys.",
      "explanation": "Hash Maps (or Dictionaries) are ideal for problems that require very fast retrieval of values when provided with a unique key, offering average O(1) lookup time."
    },
    {
      "question": "Discuss how 'abstraction' is applied when defining classes in object-oriented programming.",
      "options": [
        "Abstraction hides all details, including essential ones, within a class.",
        "Classes define objects with specific brands and physical attributes.",
        "Classes use abstraction to define objects by their essential properties (attributes) and behaviors (methods), hiding implementation details.",
        "Abstraction is not used in object-oriented programming."
      ],
      "answer": "Classes use abstraction to define objects by their essential properties (attributes) and behaviors (methods), hiding implementation details.",
      "explanation": "In object-oriented programming, classes apply abstraction by defining objects based on their essential characteristics (attributes) and actions (methods), thereby concealing unnecessary implementation complexities."
    },
    {
      "question": "Explain how 'problem decomposition' relates to breaking down a software project into individual sprints or modules.",
      "options": [
        "It's an unrelated concept; sprints are for project management.",
        "Problem decomposition is a foundational concept: a large project is broken into smaller, independent sprints/modules, each solvable separately.",
        "It focuses on solving the entire project at once.",
        "Decomposition ensures all modules are highly interdependent."
      ],
      "answer": "Problem decomposition is a foundational concept: a large project is broken into smaller, independent sprints/modules, each solvable separately.",
      "explanation": "Problem decomposition is fundamental to project management methodologies like Agile sprints, where a large software project is broken down into smaller, manageable modules or tasks that can be developed and completed independently."
    },
    {
      "question": "Why is it important to test with different types of inputs, including edge cases, for a robust solution?",
      "options": [
        "To make the testing process longer.",
        "To ensure the solution only works for typical inputs.",
        "To verify that the solution handles all expected scenarios, including unusual or extreme conditions, without failure.",
        "To identify syntax errors."
      ],
      "answer": "To verify that the solution handles all expected scenarios, including unusual or extreme conditions, without failure.",
      "explanation": "Testing with diverse inputs, especially edge cases, is crucial to ensure a solution's robustness, guaranteeing that it operates correctly and reliably under a wide range of expected and extreme conditions."
    },
    {
      "question": "A developer modifies existing code to improve its structure and readability without changing its functionality. What is this process called?",
      "options": [
        "Debugging.",
        "Refactoring.",
        "New feature development.",
        "System testing."
      ],
      "answer": "Refactoring.",
      "explanation": "Refactoring is the process of improving the internal structure or design of existing code without altering its external behavior or functionality."
    },
    {
      "question": "How does documenting your code (Internal Documentation) help future development or maintenance?",
      "options": [
        "It makes the code harder to understand.",
        "It ensures the code is always error-free.",
        "It clarifies complex logic, assumptions, and intentions, making it easier for others (and your future self) to understand and modify.",
        "It replaces the need for testing."
      ],
      "answer": "It clarifies complex logic, assumptions, and intentions, making it easier for others (and your future self) to understand and modify.",
      "explanation": "Internal documentation, like comments in code, is vital for future development and maintenance because it clarifies intricate logic, underlying assumptions, and the programmer's intent, enabling easier understanding and modification."
    },
    {
      "question": "You are observing two algorithms solving the same problem. One consistently runs faster than the other, regardless of input size. What does this suggest about their relative Big-O complexities?",
      "options": [
        "They likely have the same Big-O complexity but different constant factors.",
        "The faster algorithm likely has a higher Big-O complexity.",
        "The faster algorithm likely has a lower Big-O complexity.",
        "Big-O complexity is irrelevant here."
      ],
      "answer": "The faster algorithm likely has a lower Big-O complexity.",
      "explanation": "If one algorithm consistently outperforms another across varying input sizes, it generally suggests that the faster algorithm has a more efficient (lower) Big-O complexity, indicating a better scaling behavior."
    },
    {
      "question": "Why might a programmer choose pseudocode over a flowchart for planning a solution that involves complex conditional logic?",
      "options": [
        "Flowcharts are always easier for complex logic.",
        "Pseudocode is more visually appealing for complex branching.",
        "Pseudocode can represent complex conditional logic and nested structures more compactly and textually, avoiding sprawling diagrams.",
        "Flowcharts are not suitable for any conditional logic."
      ],
      "answer": "Pseudocode can represent complex conditional logic and nested structures more compactly and textually, avoiding sprawling diagrams.",
      "explanation": "For complex conditional logic and deeply nested structures, pseudocode can often be more concise and easier to write and read than a sprawling, intricate flowchart diagram."
    },
    {
      "question": "Consider the task of finding if a given number exists in a sorted array. Which problem-solving strategy would be most efficient, and what would its Big-O complexity likely be?",
      "options": [
        "Brute Force, O(n).",
        "Linear Search, O(n).",
        "Binary Search, O(log n).",
        "Dynamic Programming, O(n²)."
      ],
      "answer": "Binary Search, O(log n).",
      "explanation": "For a sorted array, Binary Search is the most efficient strategy. It repeatedly divides the search interval in half, leading to a logarithmic time complexity of O(log n)."
    },
    {
      "question": "What are the potential consequences of skipping the 'Understand the Problem' phase entirely?",
      "options": [
        "Faster development time and higher quality code.",
        "A perfectly clear and concise problem definition.",
        "Developing a solution for the wrong problem, inefficient code, or rework.",
        "Elimination of all logical errors."
      ],
      "answer": "Developing a solution for the wrong problem, inefficient code, or rework.",
      "explanation": "Skipping the 'Understand the Problem' phase can lead to significant issues, such as creating a solution that addresses the wrong problem, developing inefficient code, or necessitating costly rework later in the development cycle."
    },
    {
      "question": "How does the concept of 'reusability' (mentioned as a benefit of abstraction) translate into practical software development?",
      "options": [
        "It means every new project starts from scratch.",
        "It involves creating generic components (classes, functions) that can be used in multiple parts of a system or across different projects.",
        "It requires copying and pasting code frequently.",
        "It leads to highly specialized and non-transferable code."
      ],
      "answer": "It involves creating generic components (classes, functions) that can be used in multiple parts of a system or across different projects.",
      "explanation": "In practical software development, reusability means designing generic classes, functions, or modules that can be effectively utilized in various parts of the current system or even integrated into entirely different projects, reducing development effort."
    },
    {
      "question": "Which type of problems are best suited for the Greedy method?",
      "options": [
        "When locally optimal choices lead to global solutions",
        "When sub-problems are independent",
        "When recursion is required",
        "When only linear search is possible"
      ],
      "answer": "When locally optimal choices lead to global solutions",
      "explanation": "The Greedy method works best for problems where making the best local choice at each step consistently leads to the best overall (global) solution."
    },
    {
      "question": "Which approach in dynamic programming uses recursion and caching?",
      "options": [
        "Bottom-up",
        "Top-down",
        "Greedy",
        "Divide and Conquer"
      ],
      "answer": "Top-down",
      "explanation": "The Top-down approach in dynamic programming often involves recursion with memoization (caching) to store the results of sub-problems and avoid re-computation."
    },
    {
      "question": "What is F(3) in the Fibonacci sequence (where F(0)=0, F(1)=1)?",
      "options": [
        "2",
        "3",
        "4",
        "5"
      ],
      "answer": "2",
      "explanation": "The Fibonacci sequence starts F(0)=0, F(1)=1, F(2)=F(1)+F(0)=1, F(3)=F(2)+F(1)=1+1=2."
    },
    {
      "question": "Which of the following correctly represents the recursive formula for Fibonacci numbers?",
      "options": [
        "F(n) = F(n+1) + F(n+2)",
        "F(n) = F(n-2) – F(n-1)",
        "F(n) = 2 × F(n-1)",
        "F(n) = F(n-1) + F(n-2)"
      ],
      "answer": "F(n) = F(n-1) + F(n-2)",
      "explanation": "The Fibonacci sequence is defined by the recursive relation where each number is the sum of the two preceding ones: F(n) = F(n-1) + F(n-2)."
    },
    {
      "question": "Which algorithm divides the search interval into halves until the target element is found?",
      "options": [
        "Merge Sort",
        "Binary Search",
        "Quick Sort",
        "Knapsack"
      ],
      "answer": "Binary Search",
      "explanation": "Binary Search is an efficient algorithm that repeatedly halves the search space in a sorted list or array to find a target element."
    },
    {
      "question": "What is the process of storing sub-problem results in dynamic programming called?",
      "options": [
        "Caching",
        "Iteration",
        "Memoization",
        "Backtracking"
      ],
      "answer": "Memoization",
      "explanation": "The technique of storing the results of expensive function calls and returning the cached result when the same inputs occur again is called memoization, a core concept in dynamic programming."
    },
    {
      "question": "Which statement is true about recursion compared to iteration?",
      "options": [
        "Recursion is faster and uses less memory",
        "Recursion always avoids infinite execution",
        "Recursion is slower and uses more memory than iteration",
        "Recursion eliminates base cases"
      ],
      "answer": "Recursion is slower and uses more memory than iteration",
      "explanation": "While elegant, recursion typically incurs more overhead due to function call stack management, making it slower and more memory-intensive than an equivalent iterative solution for many problems."
    },
    {
      "question": "Which design strategy does Backtracking use?",
      "options": [
        "Divide and Conquer",
        "Brute force",
        "Greedy",
        "Dynamic Programming"
      ],
      "answer": "Brute force",
      "explanation": "Backtracking is often considered a refinement of the brute force search, systematically exploring possible solutions but intelligently pruning branches that cannot lead to a valid solution."
    },
    {
      "question": "Which of the following is NOT an example of a Greedy algorithm?",
      "options": [
        "Prim's Minimal Spanning Tree",
        "Kruskal's Algorithm",
        "Binary Search",
        "Dijkstra's Algorithm"
      ],
      "answer": "Binary Search",
      "explanation": "Prim's, Kruskal's, and Dijkstra's algorithms are all classic examples of greedy algorithms. Binary search is a divide-and-conquer search algorithm, not a greedy one."
    },
    {
      "question": "What do you understand by recursion in computer science?",
      "options": [
        "A function calling another function",
        "A function calling itself",
        "A function never terminating",
        "A loop with no end"
      ],
      "answer": "A function calling itself",
      "explanation": "In computer science, recursion is a programming technique where a function or method calls itself directly or indirectly to solve a problem."
    },
    {
      "question": "The bottom-up approach in dynamic programming is also known as:",
      "options": [
        "Backtracking",
        "Table filling method",
        "Greedy selection",
        "Divide-and-conquer method"
      ],
      "answer": "Table filling method",
      "explanation": "The bottom-up approach in dynamic programming, where solutions to smaller sub-problems are computed first and stored, is often referred to as the table-filling method because it systematically fills a table of sub-problem solutions."
    },
    {
      "question": "Which statement best differentiates Divide-and-Conquer from Dynamic Programming?",
      "options": [
        "Divide-and-Conquer stores results, Dynamic Programming does not",
        "Both always use recursion",
        "Dynamic Programming stores sub-problem results, Divide-and-Conquer does not",
        "Both always solve sub-problems multiple times"
      ],
      "answer": "Dynamic Programming stores sub-problem results, Divide-and-Conquer does not",
      "explanation": "The key distinction is that Dynamic Programming explicitly stores and reuses the results of overlapping sub-problems (memoization), whereas a pure Divide-and-Conquer approach might recompute the same sub-problems multiple times if they are independent."
    },
    {
      "question": "Which of the following is not part of the Fibonacci sequence (assuming F(0)=0, F(1)=1)?",
      "options": [
        "5",
        "8",
        "21",
        "22"
      ],
      "answer": "22",
      "explanation": "The Fibonacci sequence includes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, etc. The number 22 is not part of this sequence."
    },
    {
      "question": "Which of the following is NOT one of the Three Laws of Recursion?",
      "options": [
        "A recursive algorithm must have a base case",
        "A recursive algorithm must change its state toward the base case",
        "A recursive algorithm must call itself recursively",
        "A recursive algorithm must always use iteration"
      ],
      "answer": "A recursive algorithm must always use iteration",
      "explanation": "The Three Laws of Recursion are: 1) Must have a base case, 2) Must change state towards the base case, 3) Must call itself recursively. Recursion and iteration are distinct approaches."
    },
    {
      "question": "In the initial stage of Merge Sort, what happens to a given array that is to be sorted?",
      "options": [
        "It is fully sorted immediately",
        "It is iteratively divided into equal halves",
        "It is merged into subarrays",
        "It is compared element by element"
      ],
      "answer": "It is iteratively divided into equal halves",
      "explanation": "Merge Sort is a divide-and-conquer algorithm. Its initial stage involves repeatedly dividing the unsorted list (or array) into sublists until each sublist contains only one element (which is by definition, sorted)."
    },
    {
      "question": "The term 'atomic value' in Merge Sort refers to:",
      "options": [
        "A single element that cannot be further divided",
        "The pivot element",
        "A randomly selected subarray",
        "The largest element"
      ],
      "answer": "A single element that cannot be further divided",
      "explanation": "In Merge Sort, the division process continues until individual elements are reached. These single elements are considered 'atomic' because they cannot be further broken down and are inherently sorted."
    },
    {
      "question": "What is the title of Class 03 of Problem Solving?",
      "options": [
        "Problem Solving Process",
        "Understanding and Analyzing Problems: Problem Statement Breakdown",
        "Problem Abstraction and Decomposition",
        "Algorithm Design Basics"
      ],
      "answer": "Understanding and Analyzing Problems: Problem Statement Breakdown",
      "explanation": "The lecture materials explicitly state that Class 03 is focused on 'Understanding and Analyzing Problems: Problem Statement Breakdown'."
    },
    {
      "question": "What is a learning objective for 'Class 03: Understanding and Analyzing Problems: Problem Statement Breakdown'?",
      "options": [
        "Explain abstraction.",
        "Draw a Flow Chart.",
        "Analyze the basic principles of developing problem statement breakdown for selected problems.",
        "List general steps to problem solving."
      ],
      "answer": "Analyze the basic principles of developing problem statement breakdown for selected problems.",
      "explanation": "A key learning objective for Class 03 is the ability to analyze the fundamental principles involved in breaking down problem statements for specific problems."
    },
    {
      "question": "What is the first content item for 'Class 03: Understanding and Analyzing Problems: Problem Statement Breakdown'?",
      "options": [
        "Dividing the Spoils.",
        "Parallelepiped.",
        "Apples and Pears.",
        "A Rate Problem."
      ],
      "answer": "Parallelepiped.",
      "explanation": "The contents for Class 03 begin with 'Parallelepiped' as the first example of problem statement breakdown."
    },
    {
      "question": "In the 'Parallelepiped' problem, what are the three known measures?",
      "options": [
        "The diagonal, volume, and surface area.",
        "The length, the width, and the height.",
        "The x, y, and z coordinates.",
        "The angles of its faces."
      ],
      "answer": "The length, the width, and the height.",
      "explanation": "For the Parallelepiped problem, the known measures are explicitly stated as its length, width, and height."
    },
    {
      "question": "What is the unknown in the 'Parallelepiped' problem?",
      "options": [
        "The volume of the parallelepiped.",
        "The length of the diagonal of a parallelepiped.",
        "The surface area of the parallelepiped.",
        "The number of faces."
      ],
      "answer": "The length of the diagonal of a parallelepiped.",
      "explanation": "The problem statement for the Parallelepiped asks to find 'The length of the diagonal of a parallelepiped'."
    },
    {
      "question": "What auxiliary element is introduced to solve the 'Parallelepiped' problem using plane geometry?",
      "options": [
        "A new dimension, 'z'.",
        "An auxiliary element 'h', representing the diagonal of the base.",
        "A constant 'k'.",
        "A temporary variable 'temp'."
      ],
      "answer": "An auxiliary element 'h', representing the diagonal of the base.",
      "explanation": "To simplify the Parallelepiped problem into plane geometry, an auxiliary element 'h' (representing the diagonal of the base) is introduced."
    },
    {
      "question": "What theorem from plane geometry is applied to solve the 'Parallelepiped' problem?",
      "options": [
        "Euclidean theorem.",
        "Pythagoras’ theorem.",
        "Thales' theorem.",
        "Cosine rule."
      ],
      "answer": "Pythagoras’ theorem.",
      "explanation": "The problem solution applies knowledge of plane geometry, specifically Pythagoras' theorem, to find the hypotenuse of relevant right triangles."
    },
    {
      "question": "Write the final formula derived for the diagonal x of the parallelepiped in terms of a, b, c.",
      "options": [
        "x = a + b + c",
        "x² = a² + b² + c²",
        "x = √(a² + b²)",
        "x = a*b*c"
      ],
      "answer": "x² = a² + b² + c²",
      "explanation": "Through the application of Pythagoras' theorem twice, the final formula derived for the diagonal 'x' of the parallelepiped is x² = a² + b² + c²."
    },
    {
      "question": "In the 'Dividing the Spoils' problem, what is the total number of chestnuts gathered?",
      "options": [
        "100",
        "770",
        "300",
        "500"
      ],
      "answer": "770",
      "explanation": "The problem states that the three girls 'After gathering 770 chestnuts, ... divided them up'."
    },
    {
      "question": "What was the sharing proportion between Mary and Nellie?",
      "options": [
        "Mary took 3, Nellie took 4.",
        "Mary took 4, Nellie took 3.",
        "Mary took 6, Nellie took 7.",
        "Mary took 7, Nellie took 6."
      ],
      "answer": "Mary took 4, Nellie took 3.",
      "explanation": "The problem states 'As often as Mary took four chestnuts, Nellie took three'."
    },
    {
      "question": "What was the sharing proportion between Mary and Susie?",
      "options": [
        "Mary took 4, Susie took 3.",
        "Mary took 3, Susie took 4.",
        "Mary took 6, Susie took 7.",
        "Mary took 7, Susie took 6."
      ],
      "answer": "Mary took 6, Susie took 7.",
      "explanation": "The problem states 'for every six that Mary received, Susie took seven'."
    },
    {
      "question": "If Mary received x chestnuts, express Nellie's share in terms of x.",
      "options": [
        "x + 3",
        "3/4 * x",
        "7/6 * x",
        "x - 3"
      ],
      "answer": "3/4 * x",
      "explanation": "Given the proportion that for every 4 chestnuts Mary took, Nellie took 3, Nellie's share is (3/4) * x if Mary's share is x."
    },
    {
      "question": "If Mary received x chestnuts, express Susie's share in terms of x.",
      "options": [
        "x + 7",
        "3/4 * x",
        "7/6 * x",
        "x - 7"
      ],
      "answer": "7/6 * x",
      "explanation": "Given the proportion that for every 6 chestnuts Mary took, Susie took 7, Susie's share is (7/6) * x if Mary's share is x."
    },
    {
      "question": "What is the total number of chestnuts received by Mary in the 'Dividing the Spoils' example?",
      "options": [
        "198",
        "264",
        "308",
        "770"
      ],
      "answer": "264",
      "explanation": "Solving the equation x + (3/4)x + (7/6)x = 770 yields x = 264 for Mary's share."
    },
    {
      "question": "In the 'Apples and Pears' problem, how many boxes are there, and what labels do they have?",
      "options": [
        "Two boxes: 'Apples' and 'Pears'.",
        "Three boxes: 'Apples only', 'Pears only', and 'Apples & Pears'.",
        "Four boxes: 'Apples', 'Pears', 'Mixed', and 'Empty'.",
        "Three boxes: all unlabeled."
      ],
      "answer": "Three boxes: 'Apples only', 'Pears only', and 'Apples & Pears'.",
      "explanation": "The problem states there are 'three boxes with fruits in his barn: one box with apples, one box with pears, and one box with both apples and pears' with corresponding labels."
    },
    {
      "question": "What is the critical condition about the labels in the 'Apples and Pears' problem?",
      "options": [
        "All labels are correct.",
        "One label is correct, two are wrong.",
        "None of the labels is on the right box.",
        "Labels are only on two of the boxes."
      ],
      "answer": "None of the labels is on the right box.",
      "explanation": "The critical condition is explicitly stated: 'but none of these labels is on the right box'."
    },
    {
      "question": "From which box should you pick a fruit to solve the 'Apples and Pears' problem?",
      "options": [
        "The box labeled 'Apples only'.",
        "The box labeled 'Pears only'.",
        "The box labeled 'Apples & Pears'.",
        "Any box, it doesn't matter."
      ],
      "answer": "The box labeled 'Apples & Pears'.",
      "explanation": "To solve the problem efficiently, one should pick a fruit from the box labeled 'Apples & Pears' because its label must be incorrect, revealing its true content."
    },
    {
      "question": "If you pick an apple from the 'Apples & Pears' labeled box in the 'Apples and Pears' problem, what does that tell you about that box's actual contents?",
      "options": [
        "It actually contains pears only.",
        "It actually contains apples only.",
        "It actually contains apples & pears.",
        "Its contents remain unknown."
      ],
      "answer": "It actually contains apples only.",
      "explanation": "Since the label 'Apples & Pears' is wrong, and you picked an apple, the box must contain 'Apples only'."
    },
    {
      "question": "Based on the previous question (if 'Apples & Pears' box is 'Apples only'), what would be the actual contents of the other two boxes?",
      "options": [
        "Box labeled 'Apples only' is 'Pears only'; Box labeled 'Pears only' is 'Apples & Pears'.",
        "Box labeled 'Apples only' is 'Apples & Pears'; Box labeled 'Pears only' is 'Pears only'.",
        "Box labeled 'Apples only' is 'Apples only'; Box labeled 'Pears only' is 'Apples & Pears'.",
        "Contents cannot be determined."
      ],
      "answer": "Box labeled 'Apples only' is 'Pears only'; Box labeled 'Pears only' is 'Apples & Pears'.",
      "explanation": "If the 'Apples & Pears' box is 'Apples only', then by deduction (since all labels are wrong), the 'Apples only' box must be 'Pears only', and the 'Pears only' box must be 'Apples & Pears'."
    },
    {
      "question": "In the 'Rate Problem,' what is the shape of the vessel?",
      "options": [
        "Cylindrical.",
        "Spherical.",
        "Conical (vertex pointing downwards).",
        "Cuboid."
      ],
      "answer": "Conical (vertex pointing downwards).",
      "explanation": "The problem states that 'The vessel has the shape of a right circular cone, with horizontal base, the vertex pointing downwards'."
    },
    {
      "question": "What is the unknown in the 'Rate Problem'?",
      "options": [
        "Radius of the base 'a'.",
        "Altitude of the cone 'b'.",
        "Rate of flow into the vessel 'r'.",
        "Rate at which the surface is rising when the depth of the water is 'y' (dy/dt)."
      ],
      "answer": "Rate at which the surface is rising when the depth of the water is 'y' (dy/dt).",
      "explanation": "The problem asks to 'Find the rate at which the surface is rising when the depth of the water is y'."
    },
    {
      "question": "What notation is introduced for the 'rate of change of y with respect to time' in the 'Rate Problem'?",
      "options": [
        "dV/dt",
        "dx/dt",
        "dy/dt",
        "dr/dt"
      ],
      "answer": "dy/dt",
      "explanation": "The notation introduced for 'rate of change of y' with respect to time 't' is dy/dt."
    },
    {
      "question": "What is the formula for the volume V of a cone in terms of its radius x and height y?",
      "options": [
        "V = πx²y",
        "V = (1/3)πx²y",
        "V = (1/3)πy²x",
        "V = πx²y/2"
      ],
      "answer": "V = (1/3)πx²y",
      "explanation": "The volume V of a cone is given by the formula V = (1/3)πx²y."
    },
    {
      "question": "What relationship exists between x, y, a, b in the conical vessel problem due to similar triangles?",
      "options": [
        "x/y = a/b",
        "x/a = b/y",
        "x*a = y*b",
        "x+y = a+b"
      ],
      "answer": "x/a = y/b",
      "explanation": "Due to similar triangles, the ratio of the radius of water 'x' to the base radius 'a' is equal to the ratio of water depth 'y' to the cone's altitude 'b', i.e., x/a = y/b."
    },
    {
      "question": "Write the final numerical value obtained for dy/dt in the 'Rate Problem' given r = 2, a = 4, y = 1, b = 3.",
      "options": [
        "1",
        "2",
        "9/16",
        "16/9"
      ],
      "answer": "9/16",
      "explanation": "After substituting the given numerical values (r = 2, a = 4, y = 1, b = 3) into the derived equations and solving for dy/dt, the value obtained is 9/16, according to the example calculation."
    },
    {
      "question": "In the 'Which Side is the Ball?' problem, what are the two known positions?",
      "options": [
        "The player's orientation and the ball's orientation.",
        "The position of the player (xₚ, yₚ) and the position of the ball (xᵦ, yᵦ).",
        "The player's speed and the ball's speed.",
        "The distance between player and ball."
      ],
      "answer": "The position of the player (xₚ, yₚ) and the position of the ball (xᵦ, yᵦ).",
      "explanation": "The problem states that 'Position of player = (xₚ, yₚ) (always known)' and 'Position of ball = (xᵦ, yᵦ) (always known)'."
    },
    {
      "question": "What is the unknown to be determined in the 'Which Side is the Ball?' problem?",
      "options": [
        "The player's position.",
        "The ball's position.",
        "Whether the ball is to the left or right of the player.",
        "The player's orientation."
      ],
      "answer": "Whether the ball is to the left or right of the player.",
      "explanation": "The problem's core question is 'On which side of Ronaldo is the ball-left or right?', which is the unknown to be determined."
    },
    {
      "question": "What mathematical concept is used to determine the orientation of the ball relative to the player?",
      "options": [
        "Linear algebra.",
        "Elementary trigonometry (tan⁻¹).",
        "Calculus (derivatives).",
        "Geometry (Pythagoras' theorem)."
      ],
      "answer": "Elementary trigonometry (tan⁻¹).",
      "explanation": "The solution utilizes 'elementary trigonometry' and the inverse tangent function (tan⁻¹) to calculate the orientation of the ball relative to the player."
    },
    {
      "question": "If θᵦ > θₚ in the 'Which Side is the Ball?' problem, where is the ball relative to the player?",
      "options": [
        "Ball is right.",
        "Ball is left.",
        "Ball is in front.",
        "Ball is behind."
      ],
      "answer": "Ball is left.",
      "explanation": "One of the conditions in the solution states that if the ball's orientation (θᵦ) is greater than the player's orientation (θₚ), then the ball is to the player's left."
    },
    {
      "question": "If θᵦ = θₚ in the 'Which Side is the Ball?' problem, where is the ball relative to the player?",
      "options": [
        "Ball is right.",
        "Ball is left.",
        "Ball is in front.",
        "Ball is behind."
      ],
      "answer": "Ball is in front.",
      "explanation": "If the ball's orientation (θᵦ) is equal to the player's orientation (θₚ), it means the ball is directly in front of the player."
    },
    {
      "question": "Can the solution to the 'Which Side is the Ball?' problem be applied to robot soccer?",
      "options": [
        "No, it's irrelevant.",
        "Yes, it can be applied to problems like robot soccer.",
        "Only for static objects.",
        "Only for human players."
      ],
      "answer": "Yes, it can be applied to problems like robot soccer.",
      "explanation": "The lecture poses the question of applying this solution to a 'robot soccer problem', implying its potential applicability in such contexts."
    },
    {
      "question": "Can the solution to the 'Which Side is the Ball?' problem be applied to self-driving cars?",
      "options": [
        "No, it's too simple.",
        "Yes, a self-driving car can use it to determine if another car is in front, left, or right.",
        "Only for toy cars.",
        "Only for identifying pedestrians."
      ],
      "answer": "Yes, a self-driving car can use it to determine if another car is in front, left, or right.",
      "explanation": "The lecture explores the applicability of this solution to 'self-driving cars' to determine the relative position of other vehicles, indicating its broader utility."
    },
    {
      "question": "For the Library System Example, what are three essential details identified during abstraction?",
      "options": [
        "Physical appearance of books, furniture, exact building layout.",
        "Book titles, author names, book availability.",
        "Borrowing process, overdue handling, user authentication.",
        "User names, user IDs, user passwords."
      ],
      "answer": "Book titles, author names, book availability.",
      "explanation": "When abstracting the Library System, essential details about books include their title, author, and availability, as these are critical for system management."
    },
    {
      "question": "For the Library System Example, what are three aspects that can be ignored during abstraction?",
      "options": [
        "Books, users, borrowing process.",
        "Title, author, availability.",
        "Physical appearance of books, furniture in the library, exact building layout.",
        "Borrowing date, return date, fines."
      ],
      "answer": "Physical appearance of books, furniture in the library, exact building layout.",
      "explanation": "During abstraction for the Library System, aspects like the physical appearance of books, library furniture, and exact building layout are considered irrelevant to the core system's logic and can be ignored."
    },
    {
      "question": "List three key components into which the Library System is abstracted into classes.",
      "options": [
        "Title, Author, Availability.",
        "User, Book, LibrarySystem.",
        "Borrow, Return, CheckOverdue.",
        "Name, ID, Password."
      ],
      "answer": "User, Book, LibrarySystem.",
      "explanation": "The Library System is abstracted into key classes: 'Book' (representing book data), 'User' (representing user data), and 'LibrarySystem' (representing system functions)."
    },
    {
      "question": "List three sub-problems identified under 'Book Management' in the Library System Example.",
      "options": [
        "Register new users, track borrowing history, check overdue status.",
        "Add new books, remove books, update book status (available/borrowed).",
        "Borrow a book, return a book, calculate due dates.",
        "Calculate fines, send reminders, manage payments."
      ],
      "answer": "Add new books, remove books, update book status (available/borrowed).",
      "explanation": "Under 'Book Management', the identified sub-problems are adding new books, removing existing books, and updating their status (available or borrowed)."
    },
    {
      "question": "List two sub-problems identified under 'User Management' in the Library System Example.",
      "options": [
        "Add new books, remove books.",
        "Register new users, track user borrowing history.",
        "Borrow a book, return a book.",
        "Calculate due dates, apply fines."
      ],
      "answer": "Register new users, track user borrowing history.",
      "explanation": "For 'User Management', two identified sub-problems are registering new users in the system and tracking their borrowing history."
    },
    {
      "question": "List two sub-problems identified under 'Borrowing System' in the Library System Example.",
      "options": [
        "Register new users, update book status.",
        "Add new books, remove books.",
        "Borrow a book, return a book.",
        "Calculate due dates, apply fines."
      ],
      "answer": "Borrow a book, return a book.",
      "explanation": "Within the 'Borrowing System', the main sub-problems involve the operations of borrowing a book and returning a book."
    },
    {
      "question": "In the Simple Payroll Example, what are the three pieces of information asked from the user?",
      "options": [
        "Employee ID, gross pay, net pay.",
        "Number of hours worked, hourly rate of pay, and deductions.",
        "Number of hours worked, hourly rate of pay, and employee name.",
        "Number of hours worked, hourly rate of pay, and overtime hours."
      ],
      "answer": "Number of hours worked, hourly rate of pay, and employee name.",
      "explanation": "The payroll program primarily requests the user's name, the number of hours worked, and their hourly rate of pay."
    },
    {
      "question": "How is 'overtime pay' calculated in the Simple Payroll Example?",
      "options": [
        "It's 1.0 times the rate for hours over 37.",
        "It's 1.5 times the rate for all hours worked.",
        "It's 1.5 times the rate for any hours in excess of 37.",
        "It's 2.0 times the rate for any hours worked."
      ],
      "answer": "It's 1.5 times the rate for any hours in excess of 37.",
      "explanation": "Overtime pay is calculated at 1.5 times the standard rate for any hours worked beyond 37 hours."
    },
    {
      "question": "What are the two types of deductions calculated in the Simple Payroll Example?",
      "options": [
        "Pension and health insurance.",
        "Income tax and national insurance.",
        "Loan repayments and savings.",
        "Child support and union dues."
      ],
      "answer": "Income tax and national insurance.",
      "explanation": "The payroll system calculates two main deductions: income tax (at 20%) and national insurance (at 8%)."
    },
    {
      "question": "What is the final output of the Simple Payroll Example program?",
      "options": [
        "The gross pay.",
        "The total deductions.",
        "The net pay.",
        "A payslip to the screen."
      ],
      "answer": "A payslip to the screen.",
      "explanation": "The program's final action is to display a complete payslip to the screen, showing the calculated wage details."
    },
    {
      "question": "What is the primary focus of 'Algorithm analysis'?",
      "options": [
        "Writing new algorithms.",
        "Debugging algorithms.",
        "Comparing algorithms based on the amount of computing resources each uses.",
        "Encoding algorithms into programs."
      ],
      "answer": "Comparing algorithms based on the amount of computing resources each uses.",
      "explanation": "Algorithm analysis centers on evaluating and comparing algorithms by the quantity of computational resources (time and space) they require."
    },
    {
      "question": "What are the two main computing resources considered in algorithm analysis?",
      "options": [
        "CPU speed and hard drive space.",
        "Network bandwidth and power consumption.",
        "Memory space and execution time.",
        "User interface and backend processing."
      ],
      "answer": "Memory space and execution time.",
      "explanation": "The two critical computing resources analyzed in algorithms are the memory space consumed and the execution time taken."
    },
    {
      "question": "What is 'Benchmark analysis' used for?",
      "options": [
        "To debug errors.",
        "To write pseudocode.",
        "To measure the execution time of an algorithm.",
        "To create flowcharts."
      ],
      "answer": "To measure the execution time of an algorithm.",
      "explanation": "Benchmark analysis is a method specifically employed to quantify the execution time performance of an algorithm."
    },
    {
      "question": "Why is Big-O notation preferred over benchmark analysis for comparing algorithms?",
      "options": [
        "Benchmark analysis is more abstract.",
        "Big-O notation characterizes algorithms independent of the specific program or computer being used.",
        "Big-O notation is easier to perform.",
        "Benchmark analysis is only for theoretical algorithms."
      ],
      "answer": "Big-O notation characterizes algorithms independent of the specific program or computer being used.",
      "explanation": "Big-O notation is favored because it offers a machine-independent way to characterize algorithm performance, unlike benchmark analysis which is system-specific."
    },
    {
      "question": "What does n typically represent in Big-O notation?",
      "options": [
        "The number of lines of code.",
        "The size of the problem (input size).",
        "The number of errors.",
        "The number of functions in the algorithm."
      ],
      "answer": "The size of the problem (input size).",
      "explanation": "In Big-O notation, 'n' conventionally represents the size of the input or the problem being solved."
    },
    {
      "question": "If T(n) is the time it takes to solve a problem of size n, what is the goal of Big-O notation?",
      "options": [
        "To calculate the exact runtime of T(n).",
        "To show how T(n) changes with respect to the size of the problem (n).",
        "To prove T(n) is always constant.",
        "To determine if T(n) uses too much memory."
      ],
      "answer": "To show how T(n) changes with respect to the size of the problem (n).",
      "explanation": "The primary objective of Big-O notation is to illustrate the growth rate of an algorithm's runtime, T(n), as the problem size 'n' increases."
    },
    {
      "question": "In T(n) = 5n² + 27n + 1005, which term becomes the most important as n gets very large?",
      "options": [
        "The constant `1005` term.",
        "The `27n` term.",
        "The `5n²` term.",
        "All terms remain equally important."
      ],
      "answer": "The `5n²` term.",
      "explanation": "As 'n' grows substantially, the term with the highest exponent, `5n²`, dominates the function's value, becoming the most significant factor in its growth."
    },
    {
      "question": "Why are constant factors and lower-order terms ignored in Big-O notation for large n?",
      "options": [
        "They make the notation too complex.",
        "They don't significantly affect the growth rate of the function for large input sizes.",
        "They are only relevant for small 'n'.",
        "They are impossible to calculate."
      ],
      "answer": "They don't significantly affect the growth rate of the function for large input sizes.",
      "explanation": "In Big-O notation, constant factors and terms of lower order are omitted because their contribution to the algorithm's overall growth rate becomes negligible for sufficiently large input sizes."
    },
    {
      "question": "Name the Big-O classification for f(n) = 1.",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Constant.",
        "Quadratic."
      ],
      "answer": "Constant.",
      "explanation": "A function that has f(n) = 1, meaning its execution time is fixed regardless of input size, is classified as Constant time complexity in Big-O notation."
    },
    {
      "question": "Name the Big-O classification for f(n) = log n.",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Constant.",
        "Quadratic."
      ],
      "answer": "Logarithmic.",
      "explanation": "A function that grows logarithmically with 'n' is classified as Logarithmic time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = n.",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Constant.",
        "Quadratic."
      ],
      "answer": "Linear.",
      "explanation": "A function whose growth is directly proportional to 'n' is classified as Linear time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = n log n.",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Linearithmic.",
        "Quadratic."
      ],
      "answer": "Linearithmic.",
      "explanation": "A function whose growth is characterized by n log n is classified as Linearithmic time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = n².",
      "options": [
        "Linear.",
        "Logarithmic.",
        "Constant.",
        "Quadratic."
      ],
      "answer": "Quadratic.",
      "explanation": "A function whose growth is proportional to n² is classified as Quadratic time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = n³.",
      "options": [
        "Linear.",
        "Cubic.",
        "Quadratic.",
        "Exponential."
      ],
      "answer": "Cubic.",
      "explanation": "A function whose growth is proportional to n³ is classified as Cubic time complexity."
    },
    {
      "question": "Name the Big-O classification for f(n) = 2ⁿ.",
      "options": [
        "Linear.",
        "Polynomial.",
        "Exponential.",
        "Logarithmic."
      ],
      "answer": "Exponential.",
      "explanation": "A function whose growth rate is proportional to 2ⁿ is classified as Exponential time complexity."
    },
    {
      "question": "What is the Big-O complexity of the provided Python code snippet for sum_of_n_2 (iterative sum)?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n²)"
      ],
      "answer": "O(n)",
      "explanation": "The `sum_of_n_2` function uses a single `for` loop that iterates 'n' times, resulting in a Linear Time complexity of O(n)."
    },
    {
      "question": "What is the Big-O complexity of the provided Python code snippet for sum_of_n_3 (formula-based sum)?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n²)"
      ],
      "answer": "O(1)",
      "explanation": "The `sum_of_n_3` function, which calculates the sum using a direct formula, performs a constant number of operations regardless of 'n', thus having an O(1) (Constant Time) complexity."
    },
    {
      "question": "What is an 'anagram'?",
      "options": [
        "A string that is a palindrome.",
        "A string that contains only unique characters.",
        "A string formed by rearranging the letters of another string.",
        "A string that is sorted alphabetically."
      ],
      "answer": "A string formed by rearranging the letters of another string.",
      "explanation": "An anagram is defined as a word or phrase formed by rearranging the letters of a different word or phrase."
    },
    {
      "question": "Describe the 'Check Off Method' for anagram detection.",
      "options": [
        "It involves sorting both strings and comparing them.",
        "It counts character frequencies in both strings and compares counts.",
        "It checks off characters in the second string as they are found in the first, marking them to avoid reuse.",
        "It generates all permutations of one string and checks if the other matches."
      ],
      "answer": "It checks off characters in the second string as they are found in the first, marking them to avoid reuse.",
      "explanation": "The Check Off Method involves iterating through the first string, and for each character, searching for and marking (checking off) that character in the second string to ensure each character is matched uniquely."
    },
    {
      "question": "What is the Big-O complexity of the 'Check Off Method' for anagram detection?",
      "options": [
        "O(n)",
        "O(log n)",
        "O(n²)",
        "O(n log n)"
      ],
      "answer": "O(n²)",
      "explanation": "The Check Off Method typically involves nested loops (one for each character in the first string, and an inner loop to find it in the second string), resulting in a Quadratic Time complexity of O(n²)."
    },
    {
      "question": "Describe the 'Sort and Compare Method' for anagram detection.",
      "options": [
        "It generates permutations of one string.",
        "It sorts both strings alphabetically and then compares them directly.",
        "It counts character frequencies in both strings.",
        "It checks off characters in a list."
      ],
      "answer": "It sorts both strings alphabetically and then compares them directly.",
      "explanation": "The Sort and Compare Method works by transforming both strings into a canonical form by sorting their characters alphabetically, then directly comparing these sorted versions."
    },
    {
      "question": "What is the Big-O complexity of the 'Sort and Compare Method' for anagram detection?",
      "options": [
        "O(n)",
        "O(log n)",
        "O(n²)",
        "O(n log n)"
      ],
      "answer": "O(n log n)",
      "explanation": "The complexity of the Sort and Compare Method is primarily determined by the sorting process, which is O(n log n) for efficient sorting algorithms like Merge Sort or Quick Sort."
    },
    {
      "question": "Describe the 'Brute Force Method' for anagram detection.",
      "options": [
        "It sorts both strings alphabetically.",
        "It generates all possible permutations of the characters from one string and checks if any match the second string.",
        "It counts character frequencies in both strings.",
        "It efficiently checks characters off a list."
      ],
      "answer": "It generates all possible permutations of the characters from one string and checks if any match the second string.",
      "explanation": "The Brute Force Method for anagram detection involves exhaustively generating every possible permutation of the characters in one string and then checking each generated permutation against the second string."
    },
    {
      "question": "What is the Big-O complexity of the 'Brute Force Method' for anagram detection?",
      "options": [
        "O(n)",
        "O(n log n)",
        "O(n²)",
        "O(n!) (Factorial Time)"
      ],
      "answer": "O(n!) (Factorial Time)",
      "explanation": "The Brute Force Method has a factorial time complexity (O(n!)) because the number of permutations grows extremely rapidly with the length of the string 'n'."
    },
    {
      "question": "Why is the 'Brute Force Method' highly impractical for large strings?",
      "options": [
        "It uses too much memory.",
        "It has a very low constant factor.",
        "The number of permutations (n!) grows extremely rapidly, making it computationally expensive.",
        "It is prone to logical errors."
      ],
      "answer": "The number of permutations (n!) grows extremely rapidly, making it computationally expensive.",
      "explanation": "The Brute Force Method is impractical for large strings because the factorial growth of permutations (n!) quickly leads to astronomically high computational costs, making it infeasible."
    },
    {
      "question": "Describe the 'Count and Compare Method' for anagram detection.",
      "options": [
        "It involves generating all permutations of one string.",
        "It sorts both strings alphabetically and compares them.",
        "It counts the frequency of each character in both strings and then compares these frequency lists.",
        "It checks off characters from one string as they are found in the other."
      ],
      "answer": "It counts the frequency of each character in both strings and then compares these frequency lists.",
      "explanation": "The Count and Compare Method for anagram detection operates by creating a frequency map or list for each string, counting occurrences of each character, and then comparing these two frequency profiles."
    },
    {
      "question": "How many counters are typically used in the 'Count and Compare Method' for English alphabet strings?",
      "options": [
        "The length of the string.",
        "10.",
        "26 (one for each letter 'a' through 'z').",
        "256 (for ASCII characters)."
      ],
      "answer": "26 (one for each letter 'a' through 'z').",
      "explanation": "For strings consisting of English alphabet characters, 26 counters are typically used in the Count and Compare Method, with each counter corresponding to a letter from 'a' to 'z'."
    },
    {
      "question": "What is the Big-O complexity of the 'Count and Compare Method' for anagram detection?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n log n)"
      ],
      "answer": "O(n)",
      "explanation": "The Count and Compare Method achieves a Linear Time complexity of O(n) because it involves iterating through each string once (O(n)) and then comparing two fixed-size arrays of counts (O(1)), where the dominant factor is 'n'."
    },
    {
      "question": "In the 'Count and Compare Method', what is `ord(s1[i]) - ord('a')` used for?",
      "options": [
        "To get the ASCII value of a character.",
        "To convert a character to its numerical position in the alphabet (0-25).",
        "To count the frequency of a character.",
        "To check if a character is 'a'."
      ],
      "answer": "To convert a character to its numerical position in the alphabet (0-25).",
      "explanation": "The expression `ord(s1[i]) - ord('a')` maps a lowercase English character to an integer index between 0 and 25, suitable for array indexing (e.g., 'a' → 0, 'b' → 1)."
    },
    {
      "question": "How is the final decision made in the 'Count and Compare Method' about whether strings are anagrams?",
      "options": [
        "By comparing the original strings directly.",
        "By checking if the total character counts are the same.",
        "By comparing the two generated frequency lists; if they are identical, the strings are anagrams.",
        "By sorting one string and checking if it matches the other."
      ],
      "answer": "By comparing the two generated frequency lists; if they are identical, the strings are anagrams.",
      "explanation": "The final decision in the Count and Compare Method rests on whether the two frequency lists (one for each string) are identical; if they are, the strings are considered anagrams."
    },
    {
      "question": "What assumption is made about the input characters in the 'Count and Compare Method' shown?",
      "options": [
        "Inputs contain only uppercase letters.",
        "Inputs contain a mix of uppercase and lowercase letters.",
        "Inputs contain only numerical digits.",
        "Inputs contain only lowercase letters."
      ],
      "answer": "Inputs contain only lowercase letters.",
      "explanation": "The code `ord(char) - ord('a')` specifically targets lowercase English letters, implying an assumption that input strings will consist only of such characters for correct indexing."
    },
    {
      "question": "Which anagram detection method is generally considered the most efficient among those discussed?",
      "options": [
        "Check Off Method.",
        "Sort and Compare Method.",
        "Brute Force Method.",
        "Count and Compare Method."
      ],
      "answer": "Count and Compare Method.",
      "explanation": "Among the methods discussed, the Count and Compare Method is generally regarded as the most efficient due to its linear time complexity (O(n))."
    },
    {
      "question": "What is the Course Code for Problem Solving?",
      "options": [
        "CSC 122",
        "COS 121",
        "MTH 101",
        "PHY 101"
      ],
      "answer": "COS 121",
      "explanation": "The course materials specify COS 121 as the Course Code for Problem Solving."
    },
    {
      "question": "What is the Course Unit for Problem Solving?",
      "options": [
        "1",
        "2",
        "3",
        "4"
      ],
      "answer": "2",
      "explanation": "The Problem Solving course is assigned 2 course units in the lecture materials."
    },
    {
      "question": "Who are the two lecturers for the Problem Solving course?",
      "options": [
        "Dr. Okoloko Innocent and Mr. Keyamo Clement.",
        "Dr. Smith and Prof. Jones.",
        "Dr. Miller and Dr. Ranum.",
        "Dr. Polya and Dr. Cormen."
      ],
      "answer": "Dr. Okoloko Innocent and Mr. Keyamo Clement.",
      "explanation": "The lecture materials identify Dr. Okoloko Innocent and Mr. Keyamo Clement as the two lecturers for the Problem Solving course."
    },
    {
      "question": "What is the session year for the course?",
      "options": [
        "2023/2024",
        "2024/2025",
        "2025/2026",
        "2022/2023"
      ],
      "answer": "2024/2025",
      "explanation": "The course materials specify the session year for the course as 2024/2025."
    },
    {
      "question": "Which topics are covered in Week 2?",
      "options": [
        "Introduction to Problem Solving.",
        "Problem-Solving Process: Pseudocode, Algorithms, Flowcharts.",
        "Understanding and Analyzing Problems.",
        "Abstraction and Decomposition."
      ],
      "answer": "Problem-Solving Process: Pseudocode, Algorithms, Flowcharts.",
      "explanation": "Week 2 of the course schedule is dedicated to the 'Problem-Solving Process', including 'Pseudocode, Algorithms, Flowcharts'."
    },
    {
      "question": "Which topics are covered in Week 3?",
      "options": [
        "Introduction to Problem Solving.",
        "Problem-Solving Process: Pseudocode, Algorithms, Flowcharts.",
        "Understanding and Analyzing Problems: Problem statement breakdown.",
        "Abstraction and Decomposition."
      ],
      "answer": "Understanding and Analyzing Problems: Problem statement breakdown.",
      "explanation": "Week 3 of the course schedule focuses on 'Understanding and Analyzing Problems' through 'Problem statement breakdown'."
    },
    {
      "question": "Which topics are covered in Week 4?",
      "options": [
        "Algorithm Design Basics.",
        "Abstraction and Decomposition.",
        "Strategy: Brute Force & Greedy.",
        "Strategy: Divide and Conquer."
      ],
      "answer": "Abstraction and Decomposition.",
      "explanation": "Week 4 of the course schedule explicitly covers 'Abstraction and Decomposition'."
    },
    {
      "question": "What strategy is covered in Week 7?",
      "options": [
        "Dynamic Programming.",
        "Brute Force & Greedy.",
        "Divide and Conquer.",
        "Recursion and Backtracking."
      ],
      "answer": "Brute Force & Greedy.",
      "explanation": "Week 7 of the course schedule focuses on the 'Brute Force & Greedy' problem-solving strategies."
    },
    {
      "question": "What strategy is covered in Week 8?",
      "options": [
        "Brute Force & Greedy.",
        "Divide and Conquer.",
        "Dynamic Programming.",
        "Recursion and Backtracking."
      ],
      "answer": "Divide and Conquer.",
      "explanation": "Week 8 of the course schedule covers the 'Divide and Conquer' problem-solving strategy."
    },
    {
      "question": "What strategy is covered in Week 9?",
      "options": [
        "Divide and Conquer.",
        "Dynamic Programming: Fibonacci, Knapsack problems.",
        "Recursion and Backtracking.",
        "Debugging and Optimization."
      ],
      "answer": "Dynamic Programming: Fibonacci, Knapsack problems.",
      "explanation": "Week 9 of the course schedule is dedicated to 'Dynamic Programming', including 'Fibonacci, Knapsack problems'."
    },
    {
      "question": "When is 'Revision' scheduled in the course?",
      "options": [
        "Week 10.",
        "Week 11.",
        "Week 12.",
        "Week 13."
      ],
      "answer": "Week 13.",
      "explanation": "The course schedule indicates that 'Revision' is planned for Week 13."
    },
    {
      "question": "When is the 'Examination' scheduled?",
      "options": [
        "Week 10.",
        "Week 11.",
        "Week 14.",
        "Week 15."
      ],
      "answer": "Week 14.",
      "explanation": "The course schedule lists 'Examination' as taking place in Week 14."
    },
    {
      "question": "What is the first textbook recommended for the course?",
      "options": [
        "G. Polya, How to Solve It.",
        "Brad Miller and David Ranum, Problem Solving with Algorithms and Data Structures Using Python.",
        "Introduction to Algorithms by Cormen et al.",
        "The Art of Computer Programming by Knuth."
      ],
      "answer": "Brad Miller and David Ranum, Problem Solving with Algorithms and Data Structures Using Python.",
      "explanation": "The course resources list 'Brad Miller and David Ranum, Problem Solving with Algorithms and Data Structures Using Python' as the first recommended textbook."
    },
    {
      "question": "What is the second textbook recommended for the course?",
      "options": [
        "Brad Miller and David Ranum, Problem Solving with Algorithms and Data Structures Using Python.",
        "G. Polya, How to Solve It: A New Aspect of Mathematical Method.",
        "Discrete Mathematics and Its Applications by Rosen.",
        "Python Crash Course by Matthes."
      ],
      "answer": "G. Polya, How to Solve It: A New Aspect of Mathematical Method.",
      "explanation": "The course resources list 'G. Polya, How to Solve It: A New Aspect of Mathematical Method' as the second recommended textbook."
    },
    {
      "question": "What ISBN is listed for the first recommended textbook (Brad Miller and David Ranum)?",
      "options": [
        "0-691-02356-5",
        "1590282574",
        "978-0262033848",
        "978-0321765723"
      ],
      "answer": "1590282574",
      "explanation": "The ISBN for 'Brad Miller and David Ranum, Problem Solving with Algorithms and Data Structures Using Python' is 1590282574."
    },
    {
      "question": "What ISBN is listed for the second recommended textbook (G. Polya)?",
      "options": [
        "1590282574",
        "0-691-02356-5",
        "978-0262033848",
        "978-0321765723"
      ],
      "answer": "0-691-02356-5",
      "explanation": "The ISBN for 'G. Polya, How to Solve It: A New Aspect of Mathematical Method' is 0-691-02356-5."
    },
    {
      "question": "What is 'Home Work/Lab 1' related to from previous lectures?",
      "options": [
        "Designing a social media app.",
        "The Quadratic equation problem.",
        "The Library System Example.",
        "The Simple Payroll Example."
      ],
      "answer": "The Quadratic equation problem.",
      "explanation": "Home Work/Lab 1 requires students to write documentation for 'the Quadratic equation problem previously considered'."
    },
    {
      "question": "For 'Home Work/Lab 1', what specific program are students required to write using Heron's formula?",
      "options": [
        "A program to solve a linear equation.",
        "A program to calculate the area of a triangle.",
        "A program to find the diagonal of a parallelepiped.",
        "A program to calculate gross pay."
      ],
      "answer": "A program to calculate the area of a triangle.",
      "explanation": "Home Work/Lab 1 instructs students 'You are required to write a program to calculate the area of a triangle using the Heron’s formula'."
    },
    {
      "question": "What are the two deliverables required for 'Home Work/Lab 1'?",
      "options": [
        "A flowchart and pseudocode.",
        "A Python program and test results.",
        "Perform the 4 activities of the problem-solving process and write a report in MS Word format.",
        "An algorithm and external documentation."
      ],
      "answer": "Perform the 4 activities of the problem-solving process and write a report in MS Word format.",
      "explanation": "Home Work/Lab 1 requires students to 'a. Perform the 4 activities of the problem-solving process' and 'b. Write a report in MS Word format showing all the activities undertaken'."
    },
    {
      "question": "What format should the report for 'Home Work/Lab 1' be submitted in?",
      "options": [
        "MS Word format.",
        "PDF format.",
        "Plain text file.",
        "Executable file."
      ],
      "answer": "PDF format.",
      "explanation": "Home Work/Lab 1 specifies 'c. Submit the report in pdf format to innocent.okoloko@gmail.com'."
    },
    {
      "question": "You are tasked with analyzing a program that has a sequence of operations: first, a loop running n times, then a nested loop running n² times, and finally a constant number of operations. What is the Big-O complexity of this program?",
      "options": [
        "O(n)",
        "O(n²)",
        "O(n³)",
        "O(1)"
      ],
      "answer": "O(n²)",
      "explanation": "The nested loop running n² times dominates the complexity. Even with a linear loop and constant operations, the highest order term determines Big-O, which is O(n²)."
    },
    {
      "question": "Explain why an O(n log n) algorithm is generally preferred over an O(n²) algorithm for large datasets.",
      "options": [
        "O(n²) algorithms are easier to implement.",
        "O(n log n) algorithms use less memory.",
        "For large 'n', n log n grows significantly slower than n², leading to much faster execution times.",
        "O(n log n) algorithms are only for small datasets."
      ],
      "answer": "For large 'n', n log n grows significantly slower than n², leading to much faster execution times.",
      "explanation": "As the input size 'n' increases, n log n grows at a much slower rate than n², making O(n log n) algorithms considerably more efficient for processing large datasets compared to O(n²) algorithms."
    },
    {
      "question": "Describe a problem where a 'Greedy Approach' might lead to a suboptimal solution.",
      "options": [
        "Finding the shortest path in a graph with positive edge weights.",
        "The change-making problem with standard coin denominations (e.g., 1, 5, 10, 25 cents).",
        "The knapsack problem (where selecting items based on highest value-to-weight ratio doesn't always fill the knapsack optimally).",
        "Sorting a list of numbers."
      ],
      "answer": "The knapsack problem (where selecting items based on highest value-to-weight ratio doesn't always fill the knapsack optimally).",
      "explanation": "The knapsack problem is a classic example where a greedy approach (e.g., always picking the item with the highest value-to-weight ratio) does not always yield the globally optimal solution."
    },
    {
      "question": "When considering 'Data Structures,' why would you choose a 'Linked List' over an 'Array' in certain scenarios?",
      "options": [
        "Arrays are faster for insertions/deletions in the middle.",
        "Linked Lists are faster for random access to elements.",
        "Linked Lists offer more efficient insertions and deletions in the middle of the structure compared to arrays, which require shifting elements.",
        "Arrays use less memory for the same number of elements."
      ],
      "answer": "Linked Lists offer more efficient insertions and deletions in the middle of the structure compared to arrays, which require shifting elements.",
      "explanation": "Linked Lists are advantageous over arrays when frequent insertions or deletions are needed in the middle of the data sequence, as they avoid the costly element shifting required by arrays."
    },
    {
      "question": "What kind of problem would benefit from using 'Hash Maps/Dictionaries'?",
      "options": [
        "Problems requiring elements to be stored in a sorted order.",
        "Problems involving frequent lookups of values based on unique keys.",
        "Problems where data needs to be accessed sequentially.",
        "Problems involving hierarchical data relationships."
      ],
      "answer": "Problems involving frequent lookups of values based on unique keys.",
      "explanation": "Hash Maps (or Dictionaries) are ideal for problems that require very fast retrieval of values when provided with a unique key, offering average O(1) lookup time."
    },
    {
      "question": "Discuss how 'abstraction' is applied when defining classes in object-oriented programming.",
      "options": [
        "Abstraction hides all details, including essential ones, within a class.",
        "Classes define objects with specific brands and physical attributes.",
        "Classes use abstraction to define objects by their essential properties (attributes) and behaviors (methods), hiding implementation details.",
        "Abstraction is not used in object-oriented programming."
      ],
      "answer": "Classes use abstraction to define objects by their essential properties (attributes) and behaviors (methods), hiding implementation details.",
      "explanation": "In object-oriented programming, classes apply abstraction by defining objects based on their essential characteristics (attributes) and actions (methods), thereby concealing unnecessary implementation complexities."
    },
    {
      "question": "Explain how 'problem decomposition' relates to breaking down a software project into individual sprints or modules.",
      "options": [
        "It's an unrelated concept; sprints are for project management.",
        "Problem decomposition is a foundational concept: a large project is broken into smaller, independent sprints/modules, each solvable separately.",
        "It focuses on solving the entire project at once.",
        "Decomposition ensures all modules are highly interdependent."
      ],
      "answer": "Problem decomposition is a foundational concept: a large project is broken into smaller, independent sprints/modules, each solvable separately.",
      "explanation": "Problem decomposition is fundamental to project management methodologies like Agile sprints, where a large software project is broken down into smaller, manageable modules or tasks that can be developed and completed independently."
    },
    {
      "question": "Why is it important to test with different types of inputs, including edge cases, for a robust solution?",
      "options": [
        "To make the testing process longer.",
        "To ensure the solution only works for typical inputs.",
        "To verify that the solution handles all expected scenarios, including unusual or extreme conditions, without failure.",
        "To identify syntax errors."
      ],
      "answer": "To verify that the solution handles all expected scenarios, including unusual or extreme conditions, without failure.",
      "explanation": "Testing with diverse inputs, especially edge cases, is crucial to ensure a solution's robustness, guaranteeing that it operates correctly and reliably under a wide range of expected and extreme conditions."
    },
    {
      "question": "A developer modifies existing code to improve its structure and readability without changing its functionality. What is this process called?",
      "options": [
        "Debugging.",
        "Refactoring.",
        "New feature development.",
        "System testing."
      ],
      "answer": "Refactoring.",
      "explanation": "Refactoring is the process of improving the internal structure or design of existing code without altering its external behavior or functionality."
    },
    {
      "question": "How does documenting your code (Internal Documentation) help future development or maintenance?",
      "options": [
        "It makes the code harder to understand.",
        "It ensures the code is always error-free.",
        "It clarifies complex logic, assumptions, and intentions, making it easier for others (and your future self) to understand and modify.",
        "It replaces the need for testing."
      ],
      "answer": "It clarifies complex logic, assumptions, and intentions, making it easier for others (and your future self) to understand and modify.",
      "explanation": "Internal documentation, like comments in code, is vital for future development and maintenance because it clarifies intricate logic, underlying assumptions, and the programmer's intent, enabling easier understanding and modification."
    },
    {
      "question": "You are observing two algorithms solving the same problem. One consistently runs faster than the other, regardless of input size. What does this suggest about their relative Big-O complexities?",
      "options": [
        "They likely have the same Big-O complexity but different constant factors.",
        "The faster algorithm likely has a higher Big-O complexity.",
        "The faster algorithm likely has a lower Big-O complexity.",
        "Big-O complexity is irrelevant here."
      ],
      "answer": "The faster algorithm likely has a lower Big-O complexity.",
      "explanation": "If one algorithm consistently outperforms another across varying input sizes, it generally suggests that the faster algorithm has a more efficient (lower) Big-O complexity, indicating a better scaling behavior."
    },
    {
      "question": "Why might a programmer choose pseudocode over a flowchart for planning a solution that involves complex conditional logic?",
      "options": [
        "Flowcharts are always easier for complex logic.",
        "Pseudocode is more visually appealing for complex branching.",
        "Pseudocode can represent complex conditional logic and nested structures more compactly and textually, avoiding sprawling diagrams.",
        "Flowcharts are not suitable for any conditional logic."
      ],
      "answer": "Pseudocode can represent complex conditional logic and nested structures more compactly and textually, avoiding sprawling diagrams.",
      "explanation": "For complex conditional logic and deeply nested structures, pseudocode can often be more concise and easier to write and read than a sprawling, intricate flowchart diagram."
    },
    {
      "question": "Consider the task of finding if a given number exists in a sorted array. Which problem-solving strategy would be most efficient, and what would its Big-O complexity likely be?",
      "options": [
        "Brute Force, O(n).",
        "Linear Search, O(n).",
        "Binary Search, O(log n).",
        "Dynamic Programming, O(n²)."
      ],
      "answer": "Binary Search, O(log n).",
      "explanation": "For a sorted array, Binary Search is the most efficient strategy. It repeatedly divides the search interval in half, leading to a logarithmic time complexity of O(log n)."
    },
    {
      "question": "What are the potential consequences of skipping the 'Understand the Problem' phase entirely?",
      "options": [
        "Faster development time and higher quality code.",
        "A perfectly clear and concise problem definition.",
        "Developing a solution for the wrong problem, inefficient code, or rework.",
        "Elimination of all logical errors."
      ],
      "answer": "Developing a solution for the wrong problem, inefficient code, or rework.",
      "explanation": "Skipping the 'Understand the Problem' phase can lead to significant issues, such as creating a solution that addresses the wrong problem, developing inefficient code, or necessitating costly rework later in the development cycle."
    },
    {
      "question": "How does the concept of 'reusability' (mentioned as a benefit of abstraction) translate into practical software development?",
      "options": [
        "It means every new project starts from scratch.",
        "It involves creating generic components (classes, functions) that can be used in multiple parts of a system or across different projects.",
        "It requires copying and pasting code frequently.",
        "It leads to highly specialized and non-transferable code."
      ],
      "answer": "It involves creating generic components (classes, functions) that can be used in multiple parts of a system or across different projects.",
      "explanation": "In practical software development, reusability means designing generic classes, functions, or modules that can be effectively utilized in various parts of the current system or even integrated into entirely different projects, reducing development effort."
    }
  ]
};
